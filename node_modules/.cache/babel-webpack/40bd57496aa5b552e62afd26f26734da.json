{"ast":null,"code":"import _slicedToArray from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _get from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { coerceNumberProperty } from '@angular/cdk/coercion';\nimport { InjectionToken, Directive, forwardRef, Input, ɵɵdefineInjectable, ɵɵinject, NgZone, Injectable, Optional, Inject, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Output, ViewChild, ViewContainerRef, TemplateRef, IterableDiffers, SkipSelf, NgModule } from '@angular/core';\nimport { Subject, of, Observable, fromEvent, merge, animationFrameScheduler, asapScheduler, Subscription, isObservable } from 'rxjs';\nimport { distinctUntilChanged, auditTime, filter, takeUntil, startWith, pairwise, switchMap, shareReplay } from 'rxjs/operators';\nimport { Platform, getRtlScrollAxisType, supportsScrollBehavior, PlatformModule } from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { isDataSource, ArrayDataSource } from '@angular/cdk/collections';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** The injection token used to specify the virtual scrolling strategy. */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/cdk/bidi';\nvar _c0 = [\"contentWrapper\"];\nvar _c1 = [\"*\"];\nvar VIRTUAL_SCROLL_STRATEGY = new InjectionToken('VIRTUAL_SCROLL_STRATEGY');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Virtual scrolling strategy for lists with items of known fixed size. */\n\nvar FixedSizeVirtualScrollStrategy = /*#__PURE__*/function () {\n  /**\n   * @param itemSize The size of the items in the virtually scrolling list.\n   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n   */\n  function FixedSizeVirtualScrollStrategy(itemSize, minBufferPx, maxBufferPx) {\n    _classCallCheck(this, FixedSizeVirtualScrollStrategy);\n\n    this._scrolledIndexChange = new Subject();\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n\n    this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\n    /** The attached viewport. */\n\n    this._viewport = null;\n    this._itemSize = itemSize;\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n  }\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n\n\n  _createClass(FixedSizeVirtualScrollStrategy, [{\n    key: \"attach\",\n    value: function attach(viewport) {\n      this._viewport = viewport;\n\n      this._updateTotalContentSize();\n\n      this._updateRenderedRange();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this._scrolledIndexChange.complete();\n\n      this._viewport = null;\n    }\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n\n  }, {\n    key: \"updateItemAndBufferSize\",\n    value: function updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n      if (maxBufferPx < minBufferPx) {\n        throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n      }\n\n      this._itemSize = itemSize;\n      this._minBufferPx = minBufferPx;\n      this._maxBufferPx = maxBufferPx;\n\n      this._updateTotalContentSize();\n\n      this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n\n  }, {\n    key: \"onContentScrolled\",\n    value: function onContentScrolled() {\n      this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n\n  }, {\n    key: \"onDataLengthChanged\",\n    value: function onDataLengthChanged() {\n      this._updateTotalContentSize();\n\n      this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n\n  }, {\n    key: \"onContentRendered\",\n    value: function onContentRendered() {}\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n\n  }, {\n    key: \"onRenderedOffsetChanged\",\n    value: function onRenderedOffsetChanged() {}\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n\n  }, {\n    key: \"scrollToIndex\",\n    value: function scrollToIndex(index, behavior) {\n      if (this._viewport) {\n        this._viewport.scrollToOffset(index * this._itemSize, behavior);\n      }\n    }\n    /** Update the viewport's total content size. */\n\n  }, {\n    key: \"_updateTotalContentSize\",\n    value: function _updateTotalContentSize() {\n      if (!this._viewport) {\n        return;\n      }\n\n      this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n    }\n    /** Update the viewport's rendered range. */\n\n  }, {\n    key: \"_updateRenderedRange\",\n    value: function _updateRenderedRange() {\n      if (!this._viewport) {\n        return;\n      }\n\n      var renderedRange = this._viewport.getRenderedRange();\n\n      var newRange = {\n        start: renderedRange.start,\n        end: renderedRange.end\n      };\n\n      var viewportSize = this._viewport.getViewportSize();\n\n      var dataLength = this._viewport.getDataLength();\n\n      var scrollOffset = this._viewport.measureScrollOffset();\n\n      var firstVisibleIndex = scrollOffset / this._itemSize; // If user scrolls to the bottom of the list and data changes to a smaller list\n\n      if (newRange.end > dataLength) {\n        // We have to recalculate the first visible index based on new data length and viewport size.\n        var maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n        var newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems)); // If first visible index changed we must update scroll offset to handle start/end buffers\n        // Current range must also be adjusted to cover the new position (bottom of new list).\n\n        if (firstVisibleIndex != newVisibleIndex) {\n          firstVisibleIndex = newVisibleIndex;\n          scrollOffset = newVisibleIndex * this._itemSize;\n          newRange.start = Math.floor(firstVisibleIndex);\n        }\n\n        newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n      }\n\n      var startBuffer = scrollOffset - newRange.start * this._itemSize;\n\n      if (startBuffer < this._minBufferPx && newRange.start != 0) {\n        var expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n        newRange.start = Math.max(0, newRange.start - expandStart);\n        newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n      } else {\n        var endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n\n        if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n          var expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n\n          if (expandEnd > 0) {\n            newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n            newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n          }\n        }\n      }\n\n      this._viewport.setRenderedRange(newRange);\n\n      this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n\n      this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    }\n  }]);\n\n  return FixedSizeVirtualScrollStrategy;\n}();\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\n\n\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n  return fixedSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports fixed-size items. */\n\n\nvar CdkFixedSizeVirtualScroll =\n/** @class */\nfunction () {\n  var CdkFixedSizeVirtualScroll = /*#__PURE__*/function () {\n    function CdkFixedSizeVirtualScroll() {\n      _classCallCheck(this, CdkFixedSizeVirtualScroll);\n\n      this._itemSize = 20;\n      this._minBufferPx = 100;\n      this._maxBufferPx = 200;\n      /** The scroll strategy used by this directive. */\n\n      this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n    /** The size of the items in the list (in pixels). */\n\n\n    _createClass(CdkFixedSizeVirtualScroll, [{\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n      }\n    }, {\n      key: \"itemSize\",\n      get: function get() {\n        return this._itemSize;\n      },\n      set: function set(value) {\n        this._itemSize = coerceNumberProperty(value);\n      }\n      /**\n       * The minimum amount of buffer rendered beyond the viewport (in pixels).\n       * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n       */\n\n    }, {\n      key: \"minBufferPx\",\n      get: function get() {\n        return this._minBufferPx;\n      },\n      set: function set(value) {\n        this._minBufferPx = coerceNumberProperty(value);\n      }\n      /**\n       * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n       */\n\n    }, {\n      key: \"maxBufferPx\",\n      get: function get() {\n        return this._maxBufferPx;\n      },\n      set: function set(value) {\n        this._maxBufferPx = coerceNumberProperty(value);\n      }\n    }]);\n\n    return CdkFixedSizeVirtualScroll;\n  }();\n\n  CdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) {\n    return new (t || CdkFixedSizeVirtualScroll)();\n  };\n\n  CdkFixedSizeVirtualScroll.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: CdkFixedSizeVirtualScroll,\n    selectors: [[\"cdk-virtual-scroll-viewport\", \"itemSize\", \"\"]],\n    inputs: {\n      itemSize: \"itemSize\",\n      minBufferPx: \"minBufferPx\",\n      maxBufferPx: \"maxBufferPx\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: VIRTUAL_SCROLL_STRATEGY,\n      useFactory: _fixedSizeVirtualScrollStrategyFactory,\n      deps: [forwardRef(function () {\n        return CdkFixedSizeVirtualScroll;\n      })]\n    }]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  CdkFixedSizeVirtualScroll.propDecorators = {\n    itemSize: [{\n      type: Input\n    }],\n    minBufferPx: [{\n      type: Input\n    }],\n    maxBufferPx: [{\n      type: Input\n    }]\n  };\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(CdkFixedSizeVirtualScroll, [{\n      type: Directive,\n      args: [{\n        selector: 'cdk-virtual-scroll-viewport[itemSize]',\n        providers: [{\n          provide: VIRTUAL_SCROLL_STRATEGY,\n          useFactory: _fixedSizeVirtualScrollStrategyFactory,\n          deps: [forwardRef(function () {\n            return CdkFixedSizeVirtualScroll;\n          })]\n        }]\n      }]\n    }], function () {\n      return [];\n    }, {\n      itemSize: [{\n        type: Input\n      }],\n      minBufferPx: [{\n        type: Input\n      }],\n      maxBufferPx: [{\n        type: Input\n      }]\n    });\n  })();\n\n  return CdkFixedSizeVirtualScroll;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Time in ms to throttle the scrolling events by default. */\n\n\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\n\nvar ScrollDispatcher =\n/** @class */\nfunction () {\n  var ScrollDispatcher = /*#__PURE__*/function () {\n    function ScrollDispatcher(_ngZone, _platform,\n    /** @breaking-change 11.0.0 make document required */\n    document) {\n      _classCallCheck(this, ScrollDispatcher);\n\n      this._ngZone = _ngZone;\n      this._platform = _platform;\n      /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n\n      this._scrolled = new Subject();\n      /** Keeps track of the global `scroll` and `resize` subscriptions. */\n\n      this._globalSubscription = null;\n      /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n\n      this._scrolledCount = 0;\n      /**\n       * Map of all the scrollable references that are registered with the service and their\n       * scroll event subscriptions.\n       */\n\n      this.scrollContainers = new Map();\n      this._document = document;\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n\n\n    _createClass(ScrollDispatcher, [{\n      key: \"register\",\n      value: function register(scrollable) {\n        var _this = this;\n\n        if (!this.scrollContainers.has(scrollable)) {\n          this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(function () {\n            return _this._scrolled.next(scrollable);\n          }));\n        }\n      }\n      /**\n       * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n       * @param scrollable Scrollable instance to be deregistered.\n       */\n\n    }, {\n      key: \"deregister\",\n      value: function deregister(scrollable) {\n        var scrollableReference = this.scrollContainers.get(scrollable);\n\n        if (scrollableReference) {\n          scrollableReference.unsubscribe();\n          this.scrollContainers.delete(scrollable);\n        }\n      }\n      /**\n       * Returns an observable that emits an event whenever any of the registered Scrollable\n       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n       * to override the default \"throttle\" time.\n       *\n       * **Note:** in order to avoid hitting change detection for every scroll event,\n       * all of the events emitted from this stream will be run outside the Angular zone.\n       * If you need to update any data bindings as a result of a scroll event, you have\n       * to run the callback using `NgZone.run`.\n       */\n\n    }, {\n      key: \"scrolled\",\n      value: function scrolled() {\n        var _this2 = this;\n\n        var auditTimeInMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SCROLL_TIME;\n\n        if (!this._platform.isBrowser) {\n          return of();\n        }\n\n        return new Observable(function (observer) {\n          if (!_this2._globalSubscription) {\n            _this2._addGlobalListener();\n          } // In the case of a 0ms delay, use an observable without auditTime\n          // since it does add a perceptible delay in processing overhead.\n\n\n          var subscription = auditTimeInMs > 0 ? _this2._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : _this2._scrolled.subscribe(observer);\n          _this2._scrolledCount++;\n          return function () {\n            subscription.unsubscribe();\n            _this2._scrolledCount--;\n\n            if (!_this2._scrolledCount) {\n              _this2._removeGlobalListener();\n            }\n          };\n        });\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var _this3 = this;\n\n        this._removeGlobalListener();\n\n        this.scrollContainers.forEach(function (_, container) {\n          return _this3.deregister(container);\n        });\n\n        this._scrolled.complete();\n      }\n      /**\n       * Returns an observable that emits whenever any of the\n       * scrollable ancestors of an element are scrolled.\n       * @param elementRef Element whose ancestors to listen for.\n       * @param auditTimeInMs Time to throttle the scroll events.\n       */\n\n    }, {\n      key: \"ancestorScrolled\",\n      value: function ancestorScrolled(elementRef, auditTimeInMs) {\n        var ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(function (target) {\n          return !target || ancestors.indexOf(target) > -1;\n        }));\n      }\n      /** Returns all registered Scrollables that contain the provided element. */\n\n    }, {\n      key: \"getAncestorScrollContainers\",\n      value: function getAncestorScrollContainers(elementRef) {\n        var _this4 = this;\n\n        var scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n          if (_this4._scrollableContainsElement(scrollable, elementRef)) {\n            scrollingContainers.push(scrollable);\n          }\n        });\n        return scrollingContainers;\n      }\n      /** Access injected document if available or fallback to global document reference */\n\n    }, {\n      key: \"_getDocument\",\n      value: function _getDocument() {\n        return this._document || document;\n      }\n      /** Use defaultView of injected document if available or fallback to global window reference */\n\n    }, {\n      key: \"_getWindow\",\n      value: function _getWindow() {\n        var doc = this._getDocument();\n\n        return doc.defaultView || window;\n      }\n      /** Returns true if the element is contained within the provided Scrollable. */\n\n    }, {\n      key: \"_scrollableContainsElement\",\n      value: function _scrollableContainsElement(scrollable, elementRef) {\n        var element = elementRef.nativeElement;\n        var scrollableElement = scrollable.getElementRef().nativeElement; // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n\n        do {\n          if (element == scrollableElement) {\n            return true;\n          }\n        } while (element = element.parentElement);\n\n        return false;\n      }\n      /** Sets up the global scroll listeners. */\n\n    }, {\n      key: \"_addGlobalListener\",\n      value: function _addGlobalListener() {\n        var _this5 = this;\n\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n          var window = _this5._getWindow();\n\n          return fromEvent(window.document, 'scroll').subscribe(function () {\n            return _this5._scrolled.next();\n          });\n        });\n      }\n      /** Cleans up the global scroll listener. */\n\n    }, {\n      key: \"_removeGlobalListener\",\n      value: function _removeGlobalListener() {\n        if (this._globalSubscription) {\n          this._globalSubscription.unsubscribe();\n\n          this._globalSubscription = null;\n        }\n      }\n    }]);\n\n    return ScrollDispatcher;\n  }();\n\n  ScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) {\n    return new (t || ScrollDispatcher)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(DOCUMENT, 8));\n  };\n\n  ScrollDispatcher.ɵprov = ɵɵdefineInjectable({\n    factory: function ScrollDispatcher_Factory() {\n      return new ScrollDispatcher(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(DOCUMENT, 8));\n    },\n    token: ScrollDispatcher,\n    providedIn: \"root\"\n  });\n\n  ScrollDispatcher.ctorParameters = function () {\n    return [{\n      type: NgZone\n    }, {\n      type: Platform\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  };\n  /*@__PURE__*/\n\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(ScrollDispatcher, [{\n      type: Injectable,\n      args: [{\n        providedIn: 'root'\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.NgZone\n      }, {\n        type: ɵngcc1.Platform\n      }, {\n        type: undefined,\n        decorators: [{\n          type: Optional\n        }, {\n          type: Inject,\n          args: [DOCUMENT]\n        }]\n      }];\n    }, null);\n  })();\n\n  return ScrollDispatcher;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\n\n\nvar CdkScrollable =\n/** @class */\nfunction () {\n  var CdkScrollable = /*#__PURE__*/function () {\n    function CdkScrollable(elementRef, scrollDispatcher, ngZone, dir) {\n      var _this6 = this;\n\n      _classCallCheck(this, CdkScrollable);\n\n      this.elementRef = elementRef;\n      this.scrollDispatcher = scrollDispatcher;\n      this.ngZone = ngZone;\n      this.dir = dir;\n      this._destroyed = new Subject();\n      this._elementScrolled = new Observable(function (observer) {\n        return _this6.ngZone.runOutsideAngular(function () {\n          return fromEvent(_this6.elementRef.nativeElement, 'scroll').pipe(takeUntil(_this6._destroyed)).subscribe(observer);\n        });\n      });\n    }\n\n    _createClass(CdkScrollable, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.scrollDispatcher.register(this);\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.scrollDispatcher.deregister(this);\n\n        this._destroyed.next();\n\n        this._destroyed.complete();\n      }\n      /** Returns observable that emits when a scroll event is fired on the host element. */\n\n    }, {\n      key: \"elementScrolled\",\n      value: function elementScrolled() {\n        return this._elementScrolled;\n      }\n      /** Gets the ElementRef for the viewport. */\n\n    }, {\n      key: \"getElementRef\",\n      value: function getElementRef() {\n        return this.elementRef;\n      }\n      /**\n       * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n       * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n       * left and right always refer to the left and right side of the scrolling container irrespective\n       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n       * in an RTL context.\n       * @param options specified the offsets to scroll to.\n       */\n\n    }, {\n      key: \"scrollTo\",\n      value: function scrollTo(options) {\n        var el = this.elementRef.nativeElement;\n        var isRtl = this.dir && this.dir.value == 'rtl'; // Rewrite start & end offsets as right or left offsets.\n\n        if (options.left == null) {\n          options.left = isRtl ? options.end : options.start;\n        }\n\n        if (options.right == null) {\n          options.right = isRtl ? options.start : options.end;\n        } // Rewrite the bottom offset as a top offset.\n\n\n        if (options.bottom != null) {\n          options.top = el.scrollHeight - el.clientHeight - options.bottom;\n        } // Rewrite the right offset as a left offset.\n\n\n        if (isRtl && getRtlScrollAxisType() != 0\n        /* NORMAL */\n        ) {\n            if (options.left != null) {\n              options.right = el.scrollWidth - el.clientWidth - options.left;\n            }\n\n            if (getRtlScrollAxisType() == 2\n            /* INVERTED */\n            ) {\n                options.left = options.right;\n              } else if (getRtlScrollAxisType() == 1\n            /* NEGATED */\n            ) {\n                options.left = options.right ? -options.right : options.right;\n              }\n          } else {\n          if (options.right != null) {\n            options.left = el.scrollWidth - el.clientWidth - options.right;\n          }\n        }\n\n        this._applyScrollToOptions(options);\n      }\n    }, {\n      key: \"_applyScrollToOptions\",\n      value: function _applyScrollToOptions(options) {\n        var el = this.elementRef.nativeElement;\n\n        if (supportsScrollBehavior()) {\n          el.scrollTo(options);\n        } else {\n          if (options.top != null) {\n            el.scrollTop = options.top;\n          }\n\n          if (options.left != null) {\n            el.scrollLeft = options.left;\n          }\n        }\n      }\n      /**\n       * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n       * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n       * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n       * left and right always refer to the left and right side of the scrolling container irrespective\n       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n       * in an RTL context.\n       * @param from The edge to measure from.\n       */\n\n    }, {\n      key: \"measureScrollOffset\",\n      value: function measureScrollOffset(from) {\n        var LEFT = 'left';\n        var RIGHT = 'right';\n        var el = this.elementRef.nativeElement;\n\n        if (from == 'top') {\n          return el.scrollTop;\n        }\n\n        if (from == 'bottom') {\n          return el.scrollHeight - el.clientHeight - el.scrollTop;\n        } // Rewrite start & end as left or right offsets.\n\n\n        var isRtl = this.dir && this.dir.value == 'rtl';\n\n        if (from == 'start') {\n          from = isRtl ? RIGHT : LEFT;\n        } else if (from == 'end') {\n          from = isRtl ? LEFT : RIGHT;\n        }\n\n        if (isRtl && getRtlScrollAxisType() == 2\n        /* INVERTED */\n        ) {\n            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n              return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            } else {\n              return el.scrollLeft;\n            }\n          } else if (isRtl && getRtlScrollAxisType() == 1\n        /* NEGATED */\n        ) {\n            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n              return el.scrollLeft + el.scrollWidth - el.clientWidth;\n            } else {\n              return -el.scrollLeft;\n            }\n          } else {\n          // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n          // (scrollWidth - clientWidth) when scrolled all the way right.\n          if (from == LEFT) {\n            return el.scrollLeft;\n          } else {\n            return el.scrollWidth - el.clientWidth - el.scrollLeft;\n          }\n        }\n      }\n    }]);\n\n    return CdkScrollable;\n  }();\n\n  CdkScrollable.ɵfac = function CdkScrollable_Factory(t) {\n    return new (t || CdkScrollable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8));\n  };\n\n  CdkScrollable.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: CdkScrollable,\n    selectors: [[\"\", \"cdk-scrollable\", \"\"], [\"\", \"cdkScrollable\", \"\"]]\n  });\n\n  CdkScrollable.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: ScrollDispatcher\n    }, {\n      type: NgZone\n    }, {\n      type: Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  };\n  /*@__PURE__*/\n\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(CdkScrollable, [{\n      type: Directive,\n      args: [{\n        selector: '[cdk-scrollable], [cdkScrollable]'\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.ElementRef\n      }, {\n        type: ScrollDispatcher\n      }, {\n        type: ɵngcc0.NgZone\n      }, {\n        type: ɵngcc2.Directionality,\n        decorators: [{\n          type: Optional\n        }]\n      }];\n    }, null);\n  })();\n\n  return CdkScrollable;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Time in ms to throttle the resize events by default. */\n\n\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\n\nvar ViewportRuler =\n/** @class */\nfunction () {\n  var ViewportRuler = /*#__PURE__*/function () {\n    function ViewportRuler(_platform, ngZone,\n    /** @breaking-change 11.0.0 make document required */\n    document) {\n      var _this7 = this;\n\n      _classCallCheck(this, ViewportRuler);\n\n      this._platform = _platform;\n      this._document = document;\n      ngZone.runOutsideAngular(function () {\n        var window = _this7._getWindow();\n\n        _this7._change = _platform.isBrowser ? merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange')) : of(); // Note that we need to do the subscription inside `runOutsideAngular`\n        // since subscribing is what causes the event listener to be added.\n\n        _this7._invalidateCache = _this7.change().subscribe(function () {\n          return _this7._updateViewportSize();\n        });\n      });\n    }\n\n    _createClass(ViewportRuler, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._invalidateCache.unsubscribe();\n      }\n      /** Returns the viewport's width and height. */\n\n    }, {\n      key: \"getViewportSize\",\n      value: function getViewportSize() {\n        if (!this._viewportSize) {\n          this._updateViewportSize();\n        }\n\n        var output = {\n          width: this._viewportSize.width,\n          height: this._viewportSize.height\n        }; // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n\n        if (!this._platform.isBrowser) {\n          this._viewportSize = null;\n        }\n\n        return output;\n      }\n      /** Gets a ClientRect for the viewport's bounds. */\n\n    }, {\n      key: \"getViewportRect\",\n      value: function getViewportRect() {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var scrollPosition = this.getViewportScrollPosition();\n\n        var _this$getViewportSize = this.getViewportSize(),\n            width = _this$getViewportSize.width,\n            height = _this$getViewportSize.height;\n\n        return {\n          top: scrollPosition.top,\n          left: scrollPosition.left,\n          bottom: scrollPosition.top + height,\n          right: scrollPosition.left + width,\n          height: height,\n          width: width\n        };\n      }\n      /** Gets the (top, left) scroll position of the viewport. */\n\n    }, {\n      key: \"getViewportScrollPosition\",\n      value: function getViewportScrollPosition() {\n        // While we can get a reference to the fake document\n        // during SSR, it doesn't have getBoundingClientRect.\n        if (!this._platform.isBrowser) {\n          return {\n            top: 0,\n            left: 0\n          };\n        } // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n\n\n        var document = this._getDocument();\n\n        var window = this._getWindow();\n\n        var documentElement = document.documentElement;\n        var documentRect = documentElement.getBoundingClientRect();\n        var top = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;\n        var left = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;\n        return {\n          top: top,\n          left: left\n        };\n      }\n      /**\n       * Returns a stream that emits whenever the size of the viewport changes.\n       * @param throttleTime Time in milliseconds to throttle the stream.\n       */\n\n    }, {\n      key: \"change\",\n      value: function change() {\n        var throttleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_RESIZE_TIME;\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n      }\n      /** Access injected document if available or fallback to global document reference */\n\n    }, {\n      key: \"_getDocument\",\n      value: function _getDocument() {\n        return this._document || document;\n      }\n      /** Use defaultView of injected document if available or fallback to global window reference */\n\n    }, {\n      key: \"_getWindow\",\n      value: function _getWindow() {\n        var doc = this._getDocument();\n\n        return doc.defaultView || window;\n      }\n      /** Updates the cached viewport size. */\n\n    }, {\n      key: \"_updateViewportSize\",\n      value: function _updateViewportSize() {\n        var window = this._getWindow();\n\n        this._viewportSize = this._platform.isBrowser ? {\n          width: window.innerWidth,\n          height: window.innerHeight\n        } : {\n          width: 0,\n          height: 0\n        };\n      }\n    }]);\n\n    return ViewportRuler;\n  }();\n\n  ViewportRuler.ɵfac = function ViewportRuler_Factory(t) {\n    return new (t || ViewportRuler)(ɵngcc0.ɵɵinject(ɵngcc1.Platform), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DOCUMENT, 8));\n  };\n\n  ViewportRuler.ɵprov = ɵɵdefineInjectable({\n    factory: function ViewportRuler_Factory() {\n      return new ViewportRuler(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT, 8));\n    },\n    token: ViewportRuler,\n    providedIn: \"root\"\n  });\n\n  ViewportRuler.ctorParameters = function () {\n    return [{\n      type: Platform\n    }, {\n      type: NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  };\n  /*@__PURE__*/\n\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(ViewportRuler, [{\n      type: Injectable,\n      args: [{\n        providedIn: 'root'\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc1.Platform\n      }, {\n        type: ɵngcc0.NgZone\n      }, {\n        type: undefined,\n        decorators: [{\n          type: Optional\n        }, {\n          type: Inject,\n          args: [DOCUMENT]\n        }]\n      }];\n    }, null);\n  })();\n\n  return ViewportRuler;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Checks if the given ranges are equal. */\n\n\nfunction rangesEqual(r1, r2) {\n  return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\n\n\nvar SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\n\nvar CdkVirtualScrollViewport =\n/** @class */\nfunction () {\n  var CdkVirtualScrollViewport = /*#__PURE__*/function (_CdkScrollable) {\n    _inherits(CdkVirtualScrollViewport, _CdkScrollable);\n\n    var _super = _createSuper(CdkVirtualScrollViewport);\n\n    function CdkVirtualScrollViewport(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher,\n    /**\n     * @deprecated `viewportRuler` parameter to become required.\n     * @breaking-change 11.0.0\n     */\n    viewportRuler) {\n      var _this8;\n\n      _classCallCheck(this, CdkVirtualScrollViewport);\n\n      _this8 = _super.call(this, elementRef, scrollDispatcher, ngZone, dir);\n      _this8.elementRef = elementRef;\n      _this8._changeDetectorRef = _changeDetectorRef;\n      _this8._scrollStrategy = _scrollStrategy;\n      /** Emits when the viewport is detached from a CdkVirtualForOf. */\n\n      _this8._detachedSubject = new Subject();\n      /** Emits when the rendered range changes. */\n\n      _this8._renderedRangeSubject = new Subject();\n      _this8._orientation = 'vertical'; // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n      // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n      // depending on how the strategy calculates the scrolled index, it may come at a cost to\n      // performance.\n\n      /** Emits when the index of the first element visible in the viewport changes. */\n\n      _this8.scrolledIndexChange = new Observable(function (observer) {\n        return _this8._scrollStrategy.scrolledIndexChange.subscribe(function (index) {\n          return Promise.resolve().then(function () {\n            return _this8.ngZone.run(function () {\n              return observer.next(index);\n            });\n          });\n        });\n      });\n      /** A stream that emits whenever the rendered range changes. */\n\n      _this8.renderedRangeStream = _this8._renderedRangeSubject.asObservable();\n      /**\n       * The total size of all content (in pixels), including content that is not currently rendered.\n       */\n\n      _this8._totalContentSize = 0;\n      /** A string representing the `style.width` property value to be used for the spacer element. */\n\n      _this8._totalContentWidth = '';\n      /** A string representing the `style.height` property value to be used for the spacer element. */\n\n      _this8._totalContentHeight = '';\n      /** The currently rendered range of indices. */\n\n      _this8._renderedRange = {\n        start: 0,\n        end: 0\n      };\n      /** The length of the data bound to this viewport (in number of items). */\n\n      _this8._dataLength = 0;\n      /** The size of the viewport (in pixels). */\n\n      _this8._viewportSize = 0;\n      /** The last rendered content offset that was set. */\n\n      _this8._renderedContentOffset = 0;\n      /**\n       * Whether the last rendered content offset was to the end of the content (and therefore needs to\n       * be rewritten as an offset to the start of the content).\n       */\n\n      _this8._renderedContentOffsetNeedsRewrite = false;\n      /** Whether there is a pending change detection cycle. */\n\n      _this8._isChangeDetectionPending = false;\n      /** A list of functions to run after the next change detection cycle. */\n\n      _this8._runAfterChangeDetection = [];\n      /** Subscription to changes in the viewport size. */\n\n      _this8._viewportChanges = Subscription.EMPTY;\n\n      if (!_scrollStrategy) {\n        throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n      } // @breaking-change 11.0.0 Remove null check for `viewportRuler`.\n\n\n      if (viewportRuler) {\n        _this8._viewportChanges = viewportRuler.change().subscribe(function () {\n          _this8.checkViewportSize();\n        });\n      }\n\n      return _this8;\n    }\n    /** The direction the viewport scrolls. */\n\n\n    _createClass(CdkVirtualScrollViewport, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this9 = this;\n\n        _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), \"ngOnInit\", this).call(this); // It's still too early to measure the viewport at this point. Deferring with a promise allows\n        // the Viewport to be rendered with the correct size before we measure. We run this outside the\n        // zone to avoid causing more change detection cycles. We handle the change detection loop\n        // ourselves instead.\n\n\n        this.ngZone.runOutsideAngular(function () {\n          return Promise.resolve().then(function () {\n            _this9._measureViewportSize();\n\n            _this9._scrollStrategy.attach(_this9);\n\n            _this9.elementScrolled().pipe( // Start off with a fake scroll event so we properly detect our initial position.\n            startWith(null), // Collect multiple events into one until the next animation frame. This way if\n            // there are multiple scroll events in the same frame we only need to recheck\n            // our layout once.\n            auditTime(0, SCROLL_SCHEDULER)).subscribe(function () {\n              return _this9._scrollStrategy.onContentScrolled();\n            });\n\n            _this9._markChangeDetectionNeeded();\n          });\n        });\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.detach();\n\n        this._scrollStrategy.detach(); // Complete all subjects\n\n\n        this._renderedRangeSubject.complete();\n\n        this._detachedSubject.complete();\n\n        this._viewportChanges.unsubscribe();\n\n        _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), \"ngOnDestroy\", this).call(this);\n      }\n      /** Attaches a `CdkVirtualForOf` to this viewport. */\n\n    }, {\n      key: \"attach\",\n      value: function attach(forOf) {\n        var _this10 = this;\n\n        if (this._forOf) {\n          throw Error('CdkVirtualScrollViewport is already attached.');\n        } // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n        // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n        // change detection loop ourselves.\n\n\n        this.ngZone.runOutsideAngular(function () {\n          _this10._forOf = forOf;\n\n          _this10._forOf.dataStream.pipe(takeUntil(_this10._detachedSubject)).subscribe(function (data) {\n            var newLength = data.length;\n\n            if (newLength !== _this10._dataLength) {\n              _this10._dataLength = newLength;\n\n              _this10._scrollStrategy.onDataLengthChanged();\n            }\n\n            _this10._doChangeDetection();\n          });\n        });\n      }\n      /** Detaches the current `CdkVirtualForOf`. */\n\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        this._forOf = null;\n\n        this._detachedSubject.next();\n      }\n      /** Gets the length of the data bound to this viewport (in number of items). */\n\n    }, {\n      key: \"getDataLength\",\n      value: function getDataLength() {\n        return this._dataLength;\n      }\n      /** Gets the size of the viewport (in pixels). */\n\n    }, {\n      key: \"getViewportSize\",\n      value: function getViewportSize() {\n        return this._viewportSize;\n      } // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n      // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n      // setting it to something else, but its error prone and should probably be split into\n      // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n\n      /** Get the current rendered range of items. */\n\n    }, {\n      key: \"getRenderedRange\",\n      value: function getRenderedRange() {\n        return this._renderedRange;\n      }\n      /**\n       * Sets the total size of all content (in pixels), including content that is not currently\n       * rendered.\n       */\n\n    }, {\n      key: \"setTotalContentSize\",\n      value: function setTotalContentSize(size) {\n        if (this._totalContentSize !== size) {\n          this._totalContentSize = size;\n\n          this._calculateSpacerSize();\n\n          this._markChangeDetectionNeeded();\n        }\n      }\n      /** Sets the currently rendered range of indices. */\n\n    }, {\n      key: \"setRenderedRange\",\n      value: function setRenderedRange(range) {\n        var _this11 = this;\n\n        if (!rangesEqual(this._renderedRange, range)) {\n          this._renderedRangeSubject.next(this._renderedRange = range);\n\n          this._markChangeDetectionNeeded(function () {\n            return _this11._scrollStrategy.onContentRendered();\n          });\n        }\n      }\n      /**\n       * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n       */\n\n    }, {\n      key: \"getOffsetToRenderedContentStart\",\n      value: function getOffsetToRenderedContentStart() {\n        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n      }\n      /**\n       * Sets the offset from the start of the viewport to either the start or end of the rendered data\n       * (in pixels).\n       */\n\n    }, {\n      key: \"setRenderedContentOffset\",\n      value: function setRenderedContentOffset(offset) {\n        var _this12 = this;\n\n        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'to-start';\n        // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n        // in the negative direction.\n        var isRtl = this.dir && this.dir.value == 'rtl';\n        var isHorizontal = this.orientation == 'horizontal';\n        var axis = isHorizontal ? 'X' : 'Y';\n        var axisDirection = isHorizontal && isRtl ? -1 : 1;\n        var transform = \"translate\".concat(axis, \"(\").concat(Number(axisDirection * offset), \"px)\");\n        this._renderedContentOffset = offset;\n\n        if (to === 'to-end') {\n          transform += \" translate\".concat(axis, \"(-100%)\"); // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n          // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n          // expand upward).\n\n          this._renderedContentOffsetNeedsRewrite = true;\n        }\n\n        if (this._renderedContentTransform != transform) {\n          // We know this value is safe because we parse `offset` with `Number()` before passing it\n          // into the string.\n          this._renderedContentTransform = transform;\n\n          this._markChangeDetectionNeeded(function () {\n            if (_this12._renderedContentOffsetNeedsRewrite) {\n              _this12._renderedContentOffset -= _this12.measureRenderedContentSize();\n              _this12._renderedContentOffsetNeedsRewrite = false;\n\n              _this12.setRenderedContentOffset(_this12._renderedContentOffset);\n            } else {\n              _this12._scrollStrategy.onRenderedOffsetChanged();\n            }\n          });\n        }\n      }\n      /**\n       * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n       * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n       * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n       * @param offset The offset to scroll to.\n       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n       */\n\n    }, {\n      key: \"scrollToOffset\",\n      value: function scrollToOffset(offset) {\n        var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';\n        var options = {\n          behavior: behavior\n        };\n\n        if (this.orientation === 'horizontal') {\n          options.start = offset;\n        } else {\n          options.top = offset;\n        }\n\n        this.scrollTo(options);\n      }\n      /**\n       * Scrolls to the offset for the given index.\n       * @param index The index of the element to scroll to.\n       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n       */\n\n    }, {\n      key: \"scrollToIndex\",\n      value: function scrollToIndex(index) {\n        var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';\n\n        this._scrollStrategy.scrollToIndex(index, behavior);\n      }\n      /**\n       * Gets the current scroll offset from the start of the viewport (in pixels).\n       * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n       *     in horizontal mode.\n       */\n\n    }, {\n      key: \"measureScrollOffset\",\n      value: function measureScrollOffset(from) {\n        return from ? _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), \"measureScrollOffset\", this).call(this, from) : _get(_getPrototypeOf(CdkVirtualScrollViewport.prototype), \"measureScrollOffset\", this).call(this, this.orientation === 'horizontal' ? 'start' : 'top');\n      }\n      /** Measure the combined size of all of the rendered items. */\n\n    }, {\n      key: \"measureRenderedContentSize\",\n      value: function measureRenderedContentSize() {\n        var contentEl = this._contentWrapper.nativeElement;\n        return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n      }\n      /**\n       * Measure the total combined size of the given range. Throws if the range includes items that are\n       * not rendered.\n       */\n\n    }, {\n      key: \"measureRangeSize\",\n      value: function measureRangeSize(range) {\n        if (!this._forOf) {\n          return 0;\n        }\n\n        return this._forOf.measureRangeSize(range, this.orientation);\n      }\n      /** Update the viewport dimensions and re-render. */\n\n    }, {\n      key: \"checkViewportSize\",\n      value: function checkViewportSize() {\n        // TODO: Cleanup later when add logic for handling content resize\n        this._measureViewportSize();\n\n        this._scrollStrategy.onDataLengthChanged();\n      }\n      /** Measure the viewport size. */\n\n    }, {\n      key: \"_measureViewportSize\",\n      value: function _measureViewportSize() {\n        var viewportEl = this.elementRef.nativeElement;\n        this._viewportSize = this.orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;\n      }\n      /** Queue up change detection to run. */\n\n    }, {\n      key: \"_markChangeDetectionNeeded\",\n      value: function _markChangeDetectionNeeded(runAfter) {\n        var _this13 = this;\n\n        if (runAfter) {\n          this._runAfterChangeDetection.push(runAfter);\n        } // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n        // properties sequentially we only have to run `_doChangeDetection` once at the end.\n\n\n        if (!this._isChangeDetectionPending) {\n          this._isChangeDetectionPending = true;\n          this.ngZone.runOutsideAngular(function () {\n            return Promise.resolve().then(function () {\n              _this13._doChangeDetection();\n            });\n          });\n        }\n      }\n      /** Run change detection. */\n\n    }, {\n      key: \"_doChangeDetection\",\n      value: function _doChangeDetection() {\n        var _this14 = this;\n\n        this._isChangeDetectionPending = false; // Apply the content transform. The transform can't be set via an Angular binding because\n        // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n        // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n        // the `Number` function first to coerce it to a numeric value.\n\n        this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform; // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n        // from the root, since the repeated items are content projected in. Calling `detectChanges`\n        // instead does not properly check the projected content.\n\n        this.ngZone.run(function () {\n          return _this14._changeDetectorRef.markForCheck();\n        });\n        var runAfterChangeDetection = this._runAfterChangeDetection;\n        this._runAfterChangeDetection = [];\n\n        var _iterator = _createForOfIteratorHelper(runAfterChangeDetection),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var fn = _step.value;\n            fn();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      /** Calculates the `style.width` and `style.height` for the spacer element. */\n\n    }, {\n      key: \"_calculateSpacerSize\",\n      value: function _calculateSpacerSize() {\n        this._totalContentHeight = this.orientation === 'horizontal' ? '' : \"\".concat(this._totalContentSize, \"px\");\n        this._totalContentWidth = this.orientation === 'horizontal' ? \"\".concat(this._totalContentSize, \"px\") : '';\n      }\n    }, {\n      key: \"orientation\",\n      get: function get() {\n        return this._orientation;\n      },\n      set: function set(orientation) {\n        if (this._orientation !== orientation) {\n          this._orientation = orientation;\n\n          this._calculateSpacerSize();\n        }\n      }\n    }]);\n\n    return CdkVirtualScrollViewport;\n  }(CdkScrollable);\n\n  CdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) {\n    return new (t || CdkVirtualScrollViewport)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(VIRTUAL_SCROLL_STRATEGY, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ViewportRuler, 8));\n  };\n\n  CdkVirtualScrollViewport.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n    type: CdkVirtualScrollViewport,\n    selectors: [[\"cdk-virtual-scroll-viewport\"]],\n    viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵstaticViewQuery(_c0, true);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);\n      }\n    },\n    hostAttrs: [1, \"cdk-virtual-scroll-viewport\"],\n    hostVars: 4,\n    hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"cdk-virtual-scroll-orientation-horizontal\", ctx.orientation === \"horizontal\")(\"cdk-virtual-scroll-orientation-vertical\", ctx.orientation !== \"horizontal\");\n      }\n    },\n    inputs: {\n      orientation: \"orientation\"\n    },\n    outputs: {\n      scrolledIndexChange: \"scrolledIndexChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: CdkScrollable,\n      useExisting: CdkVirtualScrollViewport\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 4,\n    consts: [[1, \"cdk-virtual-scroll-content-wrapper\"], [\"contentWrapper\", \"\"], [1, \"cdk-virtual-scroll-spacer\"]],\n    template: function CdkVirtualScrollViewport_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelement(3, \"div\", 2);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx._totalContentWidth)(\"height\", ctx._totalContentHeight);\n      }\n    },\n    styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  CdkVirtualScrollViewport.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: ChangeDetectorRef\n    }, {\n      type: NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [VIRTUAL_SCROLL_STRATEGY]\n      }]\n    }, {\n      type: Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ScrollDispatcher\n    }, {\n      type: ViewportRuler,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  };\n\n  CdkVirtualScrollViewport.propDecorators = {\n    orientation: [{\n      type: Input\n    }],\n    scrolledIndexChange: [{\n      type: Output\n    }],\n    _contentWrapper: [{\n      type: ViewChild,\n      args: ['contentWrapper', {\n        static: true\n      }]\n    }]\n  };\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(CdkVirtualScrollViewport, [{\n      type: Component,\n      args: [{\n        selector: 'cdk-virtual-scroll-viewport',\n        template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\",\n        host: {\n          'class': 'cdk-virtual-scroll-viewport',\n          '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n          '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"'\n        },\n        encapsulation: ViewEncapsulation.None,\n        changeDetection: ChangeDetectionStrategy.OnPush,\n        providers: [{\n          provide: CdkScrollable,\n          useExisting: CdkVirtualScrollViewport\n        }],\n        styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"]\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.ElementRef\n      }, {\n        type: ɵngcc0.ChangeDetectorRef\n      }, {\n        type: ɵngcc0.NgZone\n      }, {\n        type: undefined,\n        decorators: [{\n          type: Optional\n        }, {\n          type: Inject,\n          args: [VIRTUAL_SCROLL_STRATEGY]\n        }]\n      }, {\n        type: ɵngcc2.Directionality,\n        decorators: [{\n          type: Optional\n        }]\n      }, {\n        type: ScrollDispatcher\n      }, {\n        type: ViewportRuler,\n        decorators: [{\n          type: Optional\n        }]\n      }];\n    }, {\n      scrolledIndexChange: [{\n        type: Output\n      }],\n      orientation: [{\n        type: Input\n      }],\n      _contentWrapper: [{\n        type: ViewChild,\n        args: ['contentWrapper', {\n          static: true\n        }]\n      }]\n    });\n  })();\n\n  return CdkVirtualScrollViewport;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Helper to extract size from a DOM Node. */\n\n\nfunction getSize(orientation, node) {\n  var el = node;\n\n  if (!el.getBoundingClientRect) {\n    return 0;\n  }\n\n  var rect = el.getBoundingClientRect();\n  return orientation == 'horizontal' ? rect.width : rect.height;\n}\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\n\n\nvar CdkVirtualForOf =\n/** @class */\nfunction () {\n  var CdkVirtualForOf = /*#__PURE__*/function () {\n    function CdkVirtualForOf(\n    /** The view container to add items to. */\n    _viewContainerRef,\n    /** The template to use when stamping out new items. */\n    _template,\n    /** The set of available differs. */\n    _differs,\n    /** The virtual scrolling viewport that these items are being rendered in. */\n    _viewport, ngZone) {\n      var _this15 = this;\n\n      _classCallCheck(this, CdkVirtualForOf);\n\n      this._viewContainerRef = _viewContainerRef;\n      this._template = _template;\n      this._differs = _differs;\n      this._viewport = _viewport;\n      /** Emits when the rendered view of the data changes. */\n\n      this.viewChange = new Subject();\n      /** Subject that emits when a new DataSource instance is given. */\n\n      this._dataSourceChanges = new Subject();\n      /**\n       * The size of the cache used to store templates that are not being used for re-use later.\n       * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n       */\n\n      this.cdkVirtualForTemplateCacheSize = 20;\n      /** Emits whenever the data in the current DataSource changes. */\n\n      this.dataStream = this._dataSourceChanges.pipe( // Start off with null `DataSource`.\n      startWith(null), // Bundle up the previous and current data sources so we can work with both.\n      pairwise(), // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n      // new one, passing back a stream of data changes which we run through `switchMap` to give\n      // us a data stream that emits the latest data from whatever the current `DataSource` is.\n      switchMap(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            prev = _ref2[0],\n            cur = _ref2[1];\n\n        return _this15._changeDataSource(prev, cur);\n      }), // Replay the last emitted data when someone subscribes.\n      shareReplay(1));\n      /** The differ used to calculate changes to the data. */\n\n      this._differ = null;\n      /**\n       * The template cache used to hold on ot template instancess that have been stamped out, but don't\n       * currently need to be rendered. These instances will be reused in the future rather than\n       * stamping out brand new ones.\n       */\n\n      this._templateCache = [];\n      /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n\n      this._needsUpdate = false;\n      this._destroyed = new Subject();\n      this.dataStream.subscribe(function (data) {\n        _this15._data = data;\n\n        _this15._onRenderedDataChange();\n      });\n\n      this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(function (range) {\n        _this15._renderedRange = range;\n        ngZone.run(function () {\n          return _this15.viewChange.next(_this15._renderedRange);\n        });\n\n        _this15._onRenderedDataChange();\n      });\n\n      this._viewport.attach(this);\n    }\n    /** The DataSource to display. */\n\n\n    _createClass(CdkVirtualForOf, [{\n      key: \"measureRangeSize\",\n\n      /**\n       * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n       * in the specified range. Throws an error if the range includes items that are not currently\n       * rendered.\n       */\n      value: function measureRangeSize(range, orientation) {\n        if (range.start >= range.end) {\n          return 0;\n        }\n\n        if (range.start < this._renderedRange.start || range.end > this._renderedRange.end) {\n          throw Error(\"Error: attempted to measure an item that isn't rendered.\");\n        } // The index into the list of rendered views for the first item in the range.\n\n\n        var renderedStartIndex = range.start - this._renderedRange.start; // The length of the range we're measuring.\n\n        var rangeLen = range.end - range.start; // Loop over all root nodes for all items in the range and sum up their size.\n\n        var totalSize = 0;\n        var i = rangeLen;\n\n        while (i--) {\n          var view = this._viewContainerRef.get(i + renderedStartIndex);\n\n          var j = view ? view.rootNodes.length : 0;\n\n          while (j--) {\n            totalSize += getSize(orientation, view.rootNodes[j]);\n          }\n        }\n\n        return totalSize;\n      }\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        if (this._differ && this._needsUpdate) {\n          // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n          // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n          // changing (need to do this diff).\n          var changes = this._differ.diff(this._renderedItems);\n\n          if (!changes) {\n            this._updateContext();\n          } else {\n            this._applyChanges(changes);\n          }\n\n          this._needsUpdate = false;\n        }\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._viewport.detach();\n\n        this._dataSourceChanges.next();\n\n        this._dataSourceChanges.complete();\n\n        this.viewChange.complete();\n\n        this._destroyed.next();\n\n        this._destroyed.complete();\n\n        var _iterator2 = _createForOfIteratorHelper(this._templateCache),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var view = _step2.value;\n            view.destroy();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      /** React to scroll state changes in the viewport. */\n\n    }, {\n      key: \"_onRenderedDataChange\",\n      value: function _onRenderedDataChange() {\n        if (!this._renderedRange) {\n          return;\n        }\n\n        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n\n        if (!this._differ) {\n          this._differ = this._differs.find(this._renderedItems).create(this.cdkVirtualForTrackBy);\n        }\n\n        this._needsUpdate = true;\n      }\n      /** Swap out one `DataSource` for another. */\n\n    }, {\n      key: \"_changeDataSource\",\n      value: function _changeDataSource(oldDs, newDs) {\n        if (oldDs) {\n          oldDs.disconnect(this);\n        }\n\n        this._needsUpdate = true;\n        return newDs ? newDs.connect(this) : of();\n      }\n      /** Update the `CdkVirtualForOfContext` for all views. */\n\n    }, {\n      key: \"_updateContext\",\n      value: function _updateContext() {\n        var count = this._data.length;\n        var i = this._viewContainerRef.length;\n\n        while (i--) {\n          var view = this._viewContainerRef.get(i);\n\n          view.context.index = this._renderedRange.start + i;\n          view.context.count = count;\n\n          this._updateComputedContextProperties(view.context);\n\n          view.detectChanges();\n        }\n      }\n      /** Apply changes to the DOM. */\n\n    }, {\n      key: \"_applyChanges\",\n      value: function _applyChanges(changes) {\n        var _this16 = this;\n\n        // Rearrange the views to put them in the right location.\n        changes.forEachOperation(function (record, adjustedPreviousIndex, currentIndex) {\n          if (record.previousIndex == null) {\n            // Item added.\n            var view = _this16._insertViewForNewItem(currentIndex);\n\n            view.context.$implicit = record.item;\n          } else if (currentIndex == null) {\n            // Item removed.\n            _this16._cacheView(_this16._detachView(adjustedPreviousIndex));\n          } else {\n            // Item moved.\n            var _view = _this16._viewContainerRef.get(adjustedPreviousIndex);\n\n            _this16._viewContainerRef.move(_view, currentIndex);\n\n            _view.context.$implicit = record.item;\n          }\n        }); // Update $implicit for any items that had an identity change.\n\n        changes.forEachIdentityChange(function (record) {\n          var view = _this16._viewContainerRef.get(record.currentIndex);\n\n          view.context.$implicit = record.item;\n        }); // Update the context variables on all items.\n\n        var count = this._data.length;\n        var i = this._viewContainerRef.length;\n\n        while (i--) {\n          var view = this._viewContainerRef.get(i);\n\n          view.context.index = this._renderedRange.start + i;\n          view.context.count = count;\n\n          this._updateComputedContextProperties(view.context);\n        }\n      }\n      /** Cache the given detached view. */\n\n    }, {\n      key: \"_cacheView\",\n      value: function _cacheView(view) {\n        if (this._templateCache.length < this.cdkVirtualForTemplateCacheSize) {\n          this._templateCache.push(view);\n        } else {\n          var index = this._viewContainerRef.indexOf(view); // It's very unlikely that the index will ever be -1, but just in case,\n          // destroy the view on its own, otherwise destroy it through the\n          // container to ensure that all the references are removed.\n\n\n          if (index === -1) {\n            view.destroy();\n          } else {\n            this._viewContainerRef.remove(index);\n          }\n        }\n      }\n      /** Inserts a view for a new item, either from the cache or by creating a new one. */\n\n    }, {\n      key: \"_insertViewForNewItem\",\n      value: function _insertViewForNewItem(index) {\n        return this._insertViewFromCache(index) || this._createEmbeddedViewAt(index);\n      }\n      /** Update the computed properties on the `CdkVirtualForOfContext`. */\n\n    }, {\n      key: \"_updateComputedContextProperties\",\n      value: function _updateComputedContextProperties(context) {\n        context.first = context.index === 0;\n        context.last = context.index === context.count - 1;\n        context.even = context.index % 2 === 0;\n        context.odd = !context.even;\n      }\n      /** Creates a new embedded view and moves it to the given index */\n\n    }, {\n      key: \"_createEmbeddedViewAt\",\n      value: function _createEmbeddedViewAt(index) {\n        // Note that it's important that we insert the item directly at the proper index,\n        // rather than inserting it and the moving it in place, because if there's a directive\n        // on the same node that injects the `ViewContainerRef`, Angular will insert another\n        // comment node which can throw off the move when it's being repeated for all items.\n        return this._viewContainerRef.createEmbeddedView(this._template, {\n          $implicit: null,\n          // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n          // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n          cdkVirtualForOf: this._cdkVirtualForOf,\n          index: -1,\n          count: -1,\n          first: false,\n          last: false,\n          odd: false,\n          even: false\n        }, index);\n      }\n      /** Inserts a recycled view from the cache at the given index. */\n\n    }, {\n      key: \"_insertViewFromCache\",\n      value: function _insertViewFromCache(index) {\n        var cachedView = this._templateCache.pop();\n\n        if (cachedView) {\n          this._viewContainerRef.insert(cachedView, index);\n        }\n\n        return cachedView || null;\n      }\n      /** Detaches the embedded view at the given index. */\n\n    }, {\n      key: \"_detachView\",\n      value: function _detachView(index) {\n        return this._viewContainerRef.detach(index);\n      }\n    }, {\n      key: \"cdkVirtualForOf\",\n      get: function get() {\n        return this._cdkVirtualForOf;\n      },\n      set: function set(value) {\n        this._cdkVirtualForOf = value;\n\n        if (isDataSource(value)) {\n          this._dataSourceChanges.next(value);\n        } else {\n          // Slice the value if its an NgIterable to ensure we're working with an array.\n          this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.prototype.slice.call(value || [])));\n        }\n      }\n      /**\n       * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n       * the item and produces a value to be used as the item's identity when tracking changes.\n       */\n\n    }, {\n      key: \"cdkVirtualForTrackBy\",\n      get: function get() {\n        return this._cdkVirtualForTrackBy;\n      },\n      set: function set(fn) {\n        var _this17 = this;\n\n        this._needsUpdate = true;\n        this._cdkVirtualForTrackBy = fn ? function (index, item) {\n          return fn(index + (_this17._renderedRange ? _this17._renderedRange.start : 0), item);\n        } : undefined;\n      }\n      /** The template used to stamp out new elements. */\n\n    }, {\n      key: \"cdkVirtualForTemplate\",\n      set: function set(value) {\n        if (value) {\n          this._needsUpdate = true;\n          this._template = value;\n        }\n      }\n    }]);\n\n    return CdkVirtualForOf;\n  }();\n\n  CdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) {\n    return new (t || CdkVirtualForOf)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(CdkVirtualScrollViewport, 4), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  CdkVirtualForOf.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: CdkVirtualForOf,\n    selectors: [[\"\", \"cdkVirtualFor\", \"\", \"cdkVirtualForOf\", \"\"]],\n    inputs: {\n      cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\",\n      cdkVirtualForOf: \"cdkVirtualForOf\",\n      cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\",\n      cdkVirtualForTemplate: \"cdkVirtualForTemplate\"\n    }\n  });\n\n  CdkVirtualForOf.ctorParameters = function () {\n    return [{\n      type: ViewContainerRef\n    }, {\n      type: TemplateRef\n    }, {\n      type: IterableDiffers\n    }, {\n      type: CdkVirtualScrollViewport,\n      decorators: [{\n        type: SkipSelf\n      }]\n    }, {\n      type: NgZone\n    }];\n  };\n\n  CdkVirtualForOf.propDecorators = {\n    cdkVirtualForOf: [{\n      type: Input\n    }],\n    cdkVirtualForTrackBy: [{\n      type: Input\n    }],\n    cdkVirtualForTemplate: [{\n      type: Input\n    }],\n    cdkVirtualForTemplateCacheSize: [{\n      type: Input\n    }]\n  };\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(CdkVirtualForOf, [{\n      type: Directive,\n      args: [{\n        selector: '[cdkVirtualFor][cdkVirtualForOf]'\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.ViewContainerRef\n      }, {\n        type: ɵngcc0.TemplateRef\n      }, {\n        type: ɵngcc0.IterableDiffers\n      }, {\n        type: CdkVirtualScrollViewport,\n        decorators: [{\n          type: SkipSelf\n        }]\n      }, {\n        type: ɵngcc0.NgZone\n      }];\n    }, {\n      cdkVirtualForTemplateCacheSize: [{\n        type: Input\n      }],\n      cdkVirtualForOf: [{\n        type: Input\n      }],\n      cdkVirtualForTrackBy: [{\n        type: Input\n      }],\n      cdkVirtualForTemplate: [{\n        type: Input\n      }]\n    });\n  })();\n\n  return CdkVirtualForOf;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar CdkScrollableModule =\n/** @class */\nfunction () {\n  var CdkScrollableModule = function CdkScrollableModule() {\n    _classCallCheck(this, CdkScrollableModule);\n  };\n\n  CdkScrollableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: CdkScrollableModule\n  });\n  CdkScrollableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function CdkScrollableModule_Factory(t) {\n      return new (t || CdkScrollableModule)();\n    }\n  });\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CdkScrollableModule, {\n      declarations: [CdkScrollable],\n      exports: [CdkScrollable]\n    });\n  })();\n  /*@__PURE__*/\n\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(CdkScrollableModule, [{\n      type: NgModule,\n      args: [{\n        exports: [CdkScrollable],\n        declarations: [CdkScrollable]\n      }]\n    }], null, null);\n  })();\n\n  return CdkScrollableModule;\n}();\n\nvar ScrollingModule =\n/** @class */\nfunction () {\n  var ScrollingModule = function ScrollingModule() {\n    _classCallCheck(this, ScrollingModule);\n  };\n\n  ScrollingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: ScrollingModule\n  });\n  ScrollingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function ScrollingModule_Factory(t) {\n      return new (t || ScrollingModule)();\n    },\n    imports: [[BidiModule, PlatformModule, CdkScrollableModule], BidiModule, CdkScrollableModule]\n  });\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScrollingModule, {\n      declarations: function declarations() {\n        return [CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport];\n      },\n      imports: function imports() {\n        return [BidiModule, PlatformModule, CdkScrollableModule];\n      },\n      exports: function exports() {\n        return [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport];\n      }\n    });\n  })();\n  /*@__PURE__*/\n\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(ScrollingModule, [{\n      type: NgModule,\n      args: [{\n        imports: [BidiModule, PlatformModule, CdkScrollableModule],\n        exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport],\n        declarations: [CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport]\n      }]\n    }], null, null);\n  })();\n\n  return ScrollingModule;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CdkFixedSizeVirtualScroll, CdkScrollable, CdkScrollableModule, CdkVirtualForOf, CdkVirtualScrollViewport, DEFAULT_RESIZE_TIME, DEFAULT_SCROLL_TIME, FixedSizeVirtualScrollStrategy, ScrollDispatcher, ScrollingModule, VIRTUAL_SCROLL_STRATEGY, ViewportRuler, _fixedSizeVirtualScrollStrategyFactory };","map":{"version":3,"sources":["../../../../../../src/cdk/scrolling/virtual-scroll-strategy.ts","../../../../../../src/cdk/scrolling/fixed-size-virtual-scroll.ts","../../../../../../src/cdk/scrolling/scroll-dispatcher.ts","../../../../../../src/cdk/scrolling/scrollable.ts","../../../../../../src/cdk/scrolling/viewport-ruler.ts","../../../../../../src/cdk/scrolling/virtual-scroll-viewport.ts","../../../../../../src/cdk/scrolling/virtual-for-of.ts","../../../../../../src/cdk/scrolling/scrolling-module.ts","../../../../../../src/cdk/scrolling/public-api.ts","../../../../../../src/cdk/scrolling/index.ts"],"names":["observableOf"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {CdkVirtualScrollViewport} from './virtual-scroll-viewport';\n\n\n/** The injection token used to specify the virtual scrolling strategy. */\nexport const VIRTUAL_SCROLL_STRATEGY =\n    new InjectionToken<VirtualScrollStrategy>('VIRTUAL_SCROLL_STRATEGY');\n\n\n/** A strategy that dictates which items should be rendered in the viewport. */\nexport interface VirtualScrollStrategy {\n  /** Emits when the index of the first element visible in the viewport changes. */\n  scrolledIndexChange: Observable<number>;\n\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport: CdkVirtualScrollViewport): void;\n\n  /** Detaches this scroll strategy from the currently attached viewport. */\n  detach(): void;\n\n  /** Called when the viewport is scrolled (debounced using requestAnimationFrame). */\n  onContentScrolled(): void;\n\n  /** Called when the length of the data changes. */\n  onDataLengthChanged(): void;\n\n  /** Called when the range of items rendered in the DOM has changed. */\n  onContentRendered(): void;\n\n  /** Called when the offset of the rendered items changed. */\n  onRenderedOffsetChanged(): void;\n\n  /**\n   * Scroll to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling.\n   */\n  scrollToIndex(index: number, behavior: ScrollBehavior): void;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceNumberProperty, NumberInput} from '@angular/cdk/coercion';\nimport {Directive, forwardRef, Input, OnChanges} from '@angular/core';\nimport {Observable, Subject} from 'rxjs';\nimport {distinctUntilChanged} from 'rxjs/operators';\nimport {VIRTUAL_SCROLL_STRATEGY, VirtualScrollStrategy} from './virtual-scroll-strategy';\nimport {CdkVirtualScrollViewport} from './virtual-scroll-viewport';\n\n\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nexport class FixedSizeVirtualScrollStrategy implements VirtualScrollStrategy {\n  private _scrolledIndexChange = new Subject<number>();\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  scrolledIndexChange: Observable<number> = this._scrolledIndexChange.pipe(distinctUntilChanged());\n\n  /** The attached viewport. */\n  private _viewport: CdkVirtualScrollViewport | null = null;\n\n  /** The size of the items in the virtually scrolling list. */\n  private _itemSize: number;\n\n  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\n  private _minBufferPx: number;\n\n  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\n  private _maxBufferPx: number;\n\n  /**\n   * @param itemSize The size of the items in the virtually scrolling list.\n   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n   */\n  constructor(itemSize: number, minBufferPx: number, maxBufferPx: number) {\n    this._itemSize = itemSize;\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n  }\n\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport: CdkVirtualScrollViewport) {\n    this._viewport = viewport;\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n\n  /** Detaches this scroll strategy from the currently attached viewport. */\n  detach() {\n    this._scrolledIndexChange.complete();\n    this._viewport = null;\n  }\n\n  /**\n   * Update the item size and buffer size.\n   * @param itemSize The size of the items in the virtually scrolling list.\n   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n   */\n  updateItemAndBufferSize(itemSize: number, minBufferPx: number, maxBufferPx: number) {\n    if (maxBufferPx < minBufferPx) {\n      throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n    }\n    this._itemSize = itemSize;\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentScrolled() {\n    this._updateRenderedRange();\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onDataLengthChanged() {\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentRendered() { /* no-op */ }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onRenderedOffsetChanged() { /* no-op */ }\n\n  /**\n   * Scroll to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling.\n   */\n  scrollToIndex(index: number, behavior: ScrollBehavior): void {\n    if (this._viewport) {\n      this._viewport.scrollToOffset(index * this._itemSize, behavior);\n    }\n  }\n\n  /** Update the viewport's total content size. */\n  private _updateTotalContentSize() {\n    if (!this._viewport) {\n      return;\n    }\n\n    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n  }\n\n  /** Update the viewport's rendered range. */\n  private _updateRenderedRange() {\n    if (!this._viewport) {\n      return;\n    }\n\n    const renderedRange = this._viewport.getRenderedRange();\n    const newRange = {start: renderedRange.start, end: renderedRange.end};\n    const viewportSize = this._viewport.getViewportSize();\n    const dataLength = this._viewport.getDataLength();\n    let scrollOffset = this._viewport.measureScrollOffset();\n    let firstVisibleIndex = scrollOffset / this._itemSize;\n\n    // If user scrolls to the bottom of the list and data changes to a smaller list\n    if (newRange.end > dataLength) {\n      // We have to recalculate the first visible index based on new data length and viewport size.\n      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n      const newVisibleIndex = Math.max(0,\n          Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n\n      // If first visible index changed we must update scroll offset to handle start/end buffers\n      // Current range must also be adjusted to cover the new position (bottom of new list).\n      if (firstVisibleIndex != newVisibleIndex) {\n        firstVisibleIndex = newVisibleIndex;\n        scrollOffset = newVisibleIndex * this._itemSize;\n        newRange.start = Math.floor(firstVisibleIndex);\n      }\n\n      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n    }\n\n    const startBuffer = scrollOffset - newRange.start * this._itemSize;\n    if (startBuffer < this._minBufferPx && newRange.start != 0) {\n      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n      newRange.start = Math.max(0, newRange.start - expandStart);\n      newRange.end = Math.min(dataLength,\n          Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n    } else {\n      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n        if (expandEnd > 0) {\n          newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n          newRange.start = Math.max(0,\n              Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n        }\n      }\n    }\n\n    this._viewport.setRenderedRange(newRange);\n    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n  }\n}\n\n\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nexport function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir: CdkFixedSizeVirtualScroll) {\n  return fixedSizeDir._scrollStrategy;\n}\n\n\n/** A virtual scroll strategy that supports fixed-size items. */\n@Directive({\n  selector: 'cdk-virtual-scroll-viewport[itemSize]',\n  providers: [{\n    provide: VIRTUAL_SCROLL_STRATEGY,\n    useFactory: _fixedSizeVirtualScrollStrategyFactory,\n    deps: [forwardRef(() => CdkFixedSizeVirtualScroll)],\n  }],\n})\nexport class CdkFixedSizeVirtualScroll implements OnChanges {\n  /** The size of the items in the list (in pixels). */\n  @Input()\n  get itemSize(): number { return this._itemSize; }\n  set itemSize(value: number) { this._itemSize = coerceNumberProperty(value); }\n  _itemSize = 20;\n\n  /**\n   * The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n   */\n  @Input()\n  get minBufferPx(): number { return this._minBufferPx; }\n  set minBufferPx(value: number) { this._minBufferPx = coerceNumberProperty(value); }\n  _minBufferPx = 100;\n\n  /**\n   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n   */\n  @Input()\n  get maxBufferPx(): number { return this._maxBufferPx; }\n  set maxBufferPx(value: number) { this._maxBufferPx = coerceNumberProperty(value); }\n  _maxBufferPx = 200;\n\n  /** The scroll strategy used by this directive. */\n  _scrollStrategy =\n      new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n\n  ngOnChanges() {\n    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n  }\n\n  static ngAcceptInputType_itemSize: NumberInput;\n  static ngAcceptInputType_minBufferPx: NumberInput;\n  static ngAcceptInputType_maxBufferPx: NumberInput;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform} from '@angular/cdk/platform';\nimport {ElementRef, Injectable, NgZone, OnDestroy, Optional, Inject} from '@angular/core';\nimport {fromEvent, of as observableOf, Subject, Subscription, Observable, Observer} from 'rxjs';\nimport {auditTime, filter} from 'rxjs/operators';\nimport {CdkScrollable} from './scrollable';\nimport {DOCUMENT} from '@angular/common';\n\n/** Time in ms to throttle the scrolling events by default. */\nexport const DEFAULT_SCROLL_TIME = 20;\n\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\n@Injectable({providedIn: 'root'})\nexport class ScrollDispatcher implements OnDestroy {\n  /** Used to reference correct document/window */\n  protected _document?: Document;\n\n  constructor(private _ngZone: NgZone,\n              private _platform: Platform,\n              /** @breaking-change 11.0.0 make document required */\n              @Optional() @Inject(DOCUMENT) document?: any) {\n    this._document = document;\n  }\n\n  /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n  private _scrolled = new Subject<CdkScrollable|void>();\n\n  /** Keeps track of the global `scroll` and `resize` subscriptions. */\n  _globalSubscription: Subscription | null = null;\n\n  /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n  private _scrolledCount = 0;\n\n  /**\n   * Map of all the scrollable references that are registered with the service and their\n   * scroll event subscriptions.\n   */\n  scrollContainers: Map<CdkScrollable, Subscription> = new Map();\n\n  /**\n   * Registers a scrollable instance with the service and listens for its scrolled events. When the\n   * scrollable is scrolled, the service emits the event to its scrolled observable.\n   * @param scrollable Scrollable instance to be registered.\n   */\n  register(scrollable: CdkScrollable): void {\n    if (!this.scrollContainers.has(scrollable)) {\n      this.scrollContainers.set(scrollable, scrollable.elementScrolled()\n          .subscribe(() => this._scrolled.next(scrollable)));\n    }\n  }\n\n  /**\n   * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n   * @param scrollable Scrollable instance to be deregistered.\n   */\n  deregister(scrollable: CdkScrollable): void {\n    const scrollableReference = this.scrollContainers.get(scrollable);\n\n    if (scrollableReference) {\n      scrollableReference.unsubscribe();\n      this.scrollContainers.delete(scrollable);\n    }\n  }\n\n  /**\n   * Returns an observable that emits an event whenever any of the registered Scrollable\n   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n   * to override the default \"throttle\" time.\n   *\n   * **Note:** in order to avoid hitting change detection for every scroll event,\n   * all of the events emitted from this stream will be run outside the Angular zone.\n   * If you need to update any data bindings as a result of a scroll event, you have\n   * to run the callback using `NgZone.run`.\n   */\n  scrolled(auditTimeInMs: number = DEFAULT_SCROLL_TIME): Observable<CdkScrollable|void> {\n    if (!this._platform.isBrowser) {\n      return observableOf<void>();\n    }\n\n    return new Observable((observer: Observer<CdkScrollable|void>) => {\n      if (!this._globalSubscription) {\n        this._addGlobalListener();\n      }\n\n      // In the case of a 0ms delay, use an observable without auditTime\n      // since it does add a perceptible delay in processing overhead.\n      const subscription = auditTimeInMs > 0 ?\n        this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n        this._scrolled.subscribe(observer);\n\n      this._scrolledCount++;\n\n      return () => {\n        subscription.unsubscribe();\n        this._scrolledCount--;\n\n        if (!this._scrolledCount) {\n          this._removeGlobalListener();\n        }\n      };\n    });\n  }\n\n  ngOnDestroy() {\n    this._removeGlobalListener();\n    this.scrollContainers.forEach((_, container) => this.deregister(container));\n    this._scrolled.complete();\n  }\n\n  /**\n   * Returns an observable that emits whenever any of the\n   * scrollable ancestors of an element are scrolled.\n   * @param elementRef Element whose ancestors to listen for.\n   * @param auditTimeInMs Time to throttle the scroll events.\n   */\n  ancestorScrolled(elementRef: ElementRef, auditTimeInMs?: number): Observable<CdkScrollable|void> {\n    const ancestors = this.getAncestorScrollContainers(elementRef);\n\n    return this.scrolled(auditTimeInMs).pipe(filter(target => {\n      return !target || ancestors.indexOf(target) > -1;\n    }));\n  }\n\n  /** Returns all registered Scrollables that contain the provided element. */\n  getAncestorScrollContainers(elementRef: ElementRef): CdkScrollable[] {\n    const scrollingContainers: CdkScrollable[] = [];\n\n    this.scrollContainers.forEach((_subscription: Subscription, scrollable: CdkScrollable) => {\n      if (this._scrollableContainsElement(scrollable, elementRef)) {\n        scrollingContainers.push(scrollable);\n      }\n    });\n\n    return scrollingContainers;\n  }\n\n  /** Access injected document if available or fallback to global document reference */\n  private _getDocument(): Document {\n    return this._document || document;\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    const doc = this._getDocument();\n    return doc.defaultView || window;\n  }\n\n  /** Returns true if the element is contained within the provided Scrollable. */\n  private _scrollableContainsElement(scrollable: CdkScrollable, elementRef: ElementRef): boolean {\n    let element: HTMLElement | null = elementRef.nativeElement;\n    let scrollableElement = scrollable.getElementRef().nativeElement;\n\n    // Traverse through the element parents until we reach null, checking if any of the elements\n    // are the scrollable's element.\n    do {\n      if (element == scrollableElement) { return true; }\n    } while (element = element!.parentElement);\n\n    return false;\n  }\n\n  /** Sets up the global scroll listeners. */\n  private _addGlobalListener() {\n    this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n      const window = this._getWindow();\n      return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\n    });\n  }\n\n  /** Cleans up the global scroll listener. */\n  private _removeGlobalListener() {\n    if (this._globalSubscription) {\n      this._globalSubscription.unsubscribe();\n      this._globalSubscription = null;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  getRtlScrollAxisType,\n  RtlScrollAxisType,\n  supportsScrollBehavior\n} from '@angular/cdk/platform';\nimport {Directive, ElementRef, NgZone, OnDestroy, OnInit, Optional} from '@angular/core';\nimport {fromEvent, Observable, Subject, Observer} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {ScrollDispatcher} from './scroll-dispatcher';\n\nexport type _Without<T> = {[P in keyof T]?: never};\nexport type _XOR<T, U> = (_Without<T> & U) | (_Without<U> & T);\nexport type _Top = {top?: number};\nexport type _Bottom = {bottom?: number};\nexport type _Left = {left?: number};\nexport type _Right = {right?: number};\nexport type _Start = {start?: number};\nexport type _End = {end?: number};\nexport type _XAxis = _XOR<_XOR<_Left, _Right>, _XOR<_Start, _End>>;\nexport type _YAxis = _XOR<_Top, _Bottom>;\n\n/**\n * An extended version of ScrollToOptions that allows expressing scroll offsets relative to the\n * top, bottom, left, right, start, or end of the viewport rather than just the top and left.\n * Please note: the top and bottom properties are mutually exclusive, as are the left, right,\n * start, and end properties.\n */\nexport type ExtendedScrollToOptions = _XAxis & _YAxis & ScrollOptions;\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\n@Directive({\n  selector: '[cdk-scrollable], [cdkScrollable]'\n})\nexport class CdkScrollable implements OnInit, OnDestroy {\n  private _destroyed = new Subject();\n\n  private _elementScrolled: Observable<Event> = new Observable((observer: Observer<Event>) =>\n      this.ngZone.runOutsideAngular(() =>\n          fromEvent(this.elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed))\n              .subscribe(observer)));\n\n  constructor(protected elementRef: ElementRef<HTMLElement>,\n              protected scrollDispatcher: ScrollDispatcher,\n              protected ngZone: NgZone,\n              @Optional() protected dir?: Directionality) {}\n\n  ngOnInit() {\n    this.scrollDispatcher.register(this);\n  }\n\n  ngOnDestroy() {\n    this.scrollDispatcher.deregister(this);\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** Returns observable that emits when a scroll event is fired on the host element. */\n  elementScrolled(): Observable<Event> {\n    return this._elementScrolled;\n  }\n\n  /** Gets the ElementRef for the viewport. */\n  getElementRef(): ElementRef<HTMLElement> {\n    return this.elementRef;\n  }\n\n  /**\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n   * left and right always refer to the left and right side of the scrolling container irrespective\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n   * in an RTL context.\n   * @param options specified the offsets to scroll to.\n   */\n  scrollTo(options: ExtendedScrollToOptions): void {\n    const el = this.elementRef.nativeElement;\n    const isRtl = this.dir && this.dir.value == 'rtl';\n\n    // Rewrite start & end offsets as right or left offsets.\n    if (options.left == null) {\n      options.left = isRtl ? options.end : options.start;\n    }\n\n    if (options.right == null) {\n      options.right = isRtl ? options.start : options.end;\n    }\n\n    // Rewrite the bottom offset as a top offset.\n    if (options.bottom != null) {\n      (options as _Without<_Bottom> & _Top).top =\n          el.scrollHeight - el.clientHeight - options.bottom;\n    }\n\n    // Rewrite the right offset as a left offset.\n    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {\n      if (options.left != null) {\n        (options as _Without<_Left> & _Right).right =\n            el.scrollWidth - el.clientWidth - options.left;\n      }\n\n      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\n        options.left = options.right;\n      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\n        options.left = options.right ? -options.right : options.right;\n      }\n    } else {\n      if (options.right != null) {\n        (options as _Without<_Right> & _Left).left =\n            el.scrollWidth - el.clientWidth - options.right;\n      }\n    }\n\n    this._applyScrollToOptions(options);\n  }\n\n  private _applyScrollToOptions(options: ScrollToOptions): void {\n    const el = this.elementRef.nativeElement;\n\n    if (supportsScrollBehavior()) {\n      el.scrollTo(options);\n    } else {\n      if (options.top != null) {\n        el.scrollTop = options.top;\n      }\n      if (options.left != null) {\n        el.scrollLeft = options.left;\n      }\n    }\n  }\n\n  /**\n   * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n   * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n   * left and right always refer to the left and right side of the scrolling container irrespective\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n   * in an RTL context.\n   * @param from The edge to measure from.\n   */\n  measureScrollOffset(from: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number {\n    const LEFT = 'left';\n    const RIGHT = 'right';\n    const el = this.elementRef.nativeElement;\n    if (from == 'top') {\n      return el.scrollTop;\n    }\n    if (from == 'bottom') {\n      return el.scrollHeight - el.clientHeight - el.scrollTop;\n    }\n\n    // Rewrite start & end as left or right offsets.\n    const isRtl = this.dir && this.dir.value == 'rtl';\n    if (from == 'start') {\n      from = isRtl ? RIGHT : LEFT;\n    } else if (from == 'end') {\n      from = isRtl ? LEFT : RIGHT;\n    }\n\n    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\n      // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n      // 0 when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollWidth - el.clientWidth - el.scrollLeft;\n      } else {\n        return el.scrollLeft;\n      }\n    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\n      // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n      // 0 when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollLeft + el.scrollWidth - el.clientWidth;\n      } else {\n        return -el.scrollLeft;\n      }\n    } else {\n      // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n      // (scrollWidth - clientWidth) when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollLeft;\n      } else {\n        return el.scrollWidth - el.clientWidth - el.scrollLeft;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform} from '@angular/cdk/platform';\nimport {Injectable, NgZone, OnDestroy, Optional, Inject} from '@angular/core';\nimport {merge, of as observableOf, fromEvent, Observable, Subscription} from 'rxjs';\nimport {auditTime} from 'rxjs/operators';\nimport {DOCUMENT} from '@angular/common';\n\n/** Time in ms to throttle the resize events by default. */\nexport const DEFAULT_RESIZE_TIME = 20;\n\n/** Object that holds the scroll position of the viewport in each direction. */\nexport interface ViewportScrollPosition {\n  top: number;\n  left: number;\n}\n\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\n@Injectable({providedIn: 'root'})\nexport class ViewportRuler implements OnDestroy {\n  /** Cached viewport dimensions. */\n  private _viewportSize: {width: number; height: number};\n\n  /** Stream of viewport change events. */\n  private _change: Observable<Event>;\n\n  /** Subscription to streams that invalidate the cached viewport dimensions. */\n  private _invalidateCache: Subscription;\n\n  /** Used to reference correct document/window */\n  protected _document?: Document;\n\n  constructor(private _platform: Platform,\n              ngZone: NgZone,\n              /** @breaking-change 11.0.0 make document required */\n              @Optional() @Inject(DOCUMENT) document?: any) {\n    this._document = document;\n\n    ngZone.runOutsideAngular(() => {\n      const window = this._getWindow();\n\n      this._change = _platform.isBrowser ?\n          merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange')) :\n          observableOf();\n\n      // Note that we need to do the subscription inside `runOutsideAngular`\n      // since subscribing is what causes the event listener to be added.\n      this._invalidateCache = this.change().subscribe(() => this._updateViewportSize());\n    });\n  }\n\n  ngOnDestroy() {\n    this._invalidateCache.unsubscribe();\n  }\n\n  /** Returns the viewport's width and height. */\n  getViewportSize(): Readonly<{width: number, height: number}> {\n    if (!this._viewportSize) {\n      this._updateViewportSize();\n    }\n\n    const output = {width: this._viewportSize.width, height: this._viewportSize.height};\n\n    // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n    if (!this._platform.isBrowser) {\n      this._viewportSize = null!;\n    }\n\n    return output;\n  }\n\n  /** Gets a ClientRect for the viewport's bounds. */\n  getViewportRect(): ClientRect {\n    // Use the document element's bounding rect rather than the window scroll properties\n    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n    // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n    // can disagree when the page is pinch-zoomed (on devices that support touch).\n    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n    // We use the documentElement instead of the body because, by default (without a css reset)\n    // browsers typically give the document body an 8px margin, which is not included in\n    // getBoundingClientRect().\n    const scrollPosition = this.getViewportScrollPosition();\n    const {width, height} = this.getViewportSize();\n\n    return {\n      top: scrollPosition.top,\n      left: scrollPosition.left,\n      bottom: scrollPosition.top + height,\n      right: scrollPosition.left + width,\n      height,\n      width,\n    };\n  }\n\n  /** Gets the (top, left) scroll position of the viewport. */\n  getViewportScrollPosition(): ViewportScrollPosition {\n    // While we can get a reference to the fake document\n    // during SSR, it doesn't have getBoundingClientRect.\n    if (!this._platform.isBrowser) {\n      return {top: 0, left: 0};\n    }\n\n    // The top-left-corner of the viewport is determined by the scroll position of the document\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n    // `document.documentElement` works consistently, where the `top` and `left` values will\n    // equal negative the scroll position.\n    const document = this._getDocument();\n    const window = this._getWindow();\n    const documentElement = document.documentElement!;\n    const documentRect = documentElement.getBoundingClientRect();\n\n    const top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n                 documentElement.scrollTop || 0;\n\n    const left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n                  documentElement.scrollLeft || 0;\n\n    return {top, left};\n  }\n\n  /**\n   * Returns a stream that emits whenever the size of the viewport changes.\n   * @param throttleTime Time in milliseconds to throttle the stream.\n   */\n  change(throttleTime: number = DEFAULT_RESIZE_TIME): Observable<Event> {\n    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n  }\n\n  /** Access injected document if available or fallback to global document reference */\n  private _getDocument(): Document {\n    return this._document || document;\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    const doc = this._getDocument();\n    return doc.defaultView || window;\n  }\n\n  /** Updates the cached viewport size. */\n  private _updateViewportSize() {\n    const window = this._getWindow();\n    this._viewportSize = this._platform.isBrowser ?\n        {width: window.innerWidth, height: window.innerHeight} :\n        {width: 0, height: 0};\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {ListRange} from '@angular/cdk/collections';\nimport {\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  animationFrameScheduler,\n  asapScheduler,\n  Observable,\n  Subject,\n  Observer,\n  Subscription,\n} from 'rxjs';\nimport {auditTime, startWith, takeUntil} from 'rxjs/operators';\nimport {ScrollDispatcher} from './scroll-dispatcher';\nimport {CdkScrollable, ExtendedScrollToOptions} from './scrollable';\nimport {CdkVirtualForOf} from './virtual-for-of';\nimport {VIRTUAL_SCROLL_STRATEGY, VirtualScrollStrategy} from './virtual-scroll-strategy';\nimport {ViewportRuler} from './viewport-ruler';\n\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1: ListRange, r2: ListRange): boolean {\n  return r1.start == r2.start && r1.end == r2.end;\n}\n\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER =\n    typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\n\n\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\n@Component({\n  selector: 'cdk-virtual-scroll-viewport',\n  templateUrl: 'virtual-scroll-viewport.html',\n  styleUrls: ['virtual-scroll-viewport.css'],\n  host: {\n    'class': 'cdk-virtual-scroll-viewport',\n    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [{\n    provide: CdkScrollable,\n    useExisting: CdkVirtualScrollViewport,\n  }]\n})\nexport class CdkVirtualScrollViewport extends CdkScrollable implements OnInit, OnDestroy {\n  /** Emits when the viewport is detached from a CdkVirtualForOf. */\n  private _detachedSubject = new Subject<void>();\n\n  /** Emits when the rendered range changes. */\n  private _renderedRangeSubject = new Subject<ListRange>();\n\n  /** The direction the viewport scrolls. */\n  @Input()\n  get orientation() {\n    return this._orientation;\n  }\n  set orientation(orientation: 'horizontal' | 'vertical') {\n    if (this._orientation !== orientation) {\n      this._orientation = orientation;\n      this._calculateSpacerSize();\n    }\n  }\n  private _orientation: 'horizontal' | 'vertical' = 'vertical';\n\n  // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n  // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n  // depending on how the strategy calculates the scrolled index, it may come at a cost to\n  // performance.\n  /** Emits when the index of the first element visible in the viewport changes. */\n  @Output() scrolledIndexChange: Observable<number> =\n      new Observable((observer: Observer<number>) =>\n        this._scrollStrategy.scrolledIndexChange.subscribe(index =>\n            Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n\n  /** The element that wraps the rendered content. */\n  @ViewChild('contentWrapper', {static: true}) _contentWrapper: ElementRef<HTMLElement>;\n\n  /** A stream that emits whenever the rendered range changes. */\n  renderedRangeStream: Observable<ListRange> = this._renderedRangeSubject.asObservable();\n\n  /**\n   * The total size of all content (in pixels), including content that is not currently rendered.\n   */\n  private _totalContentSize = 0;\n\n  /** A string representing the `style.width` property value to be used for the spacer element. */\n  _totalContentWidth = '';\n\n  /** A string representing the `style.height` property value to be used for the spacer element. */\n  _totalContentHeight = '';\n\n  /**\n   * The CSS transform applied to the rendered subset of items so that they appear within the bounds\n   * of the visible viewport.\n   */\n  private _renderedContentTransform: string;\n\n  /** The currently rendered range of indices. */\n  private _renderedRange: ListRange = {start: 0, end: 0};\n\n  /** The length of the data bound to this viewport (in number of items). */\n  private _dataLength = 0;\n\n  /** The size of the viewport (in pixels). */\n  private _viewportSize = 0;\n\n  /** the currently attached CdkVirtualForOf. */\n  private _forOf: CdkVirtualForOf<any> | null;\n\n  /** The last rendered content offset that was set. */\n  private _renderedContentOffset = 0;\n\n  /**\n   * Whether the last rendered content offset was to the end of the content (and therefore needs to\n   * be rewritten as an offset to the start of the content).\n   */\n  private _renderedContentOffsetNeedsRewrite = false;\n\n  /** Whether there is a pending change detection cycle. */\n  private _isChangeDetectionPending = false;\n\n  /** A list of functions to run after the next change detection cycle. */\n  private _runAfterChangeDetection: Function[] = [];\n\n  /** Subscription to changes in the viewport size. */\n  private _viewportChanges = Subscription.EMPTY;\n\n  constructor(public elementRef: ElementRef<HTMLElement>,\n              private _changeDetectorRef: ChangeDetectorRef,\n              ngZone: NgZone,\n              @Optional() @Inject(VIRTUAL_SCROLL_STRATEGY)\n                  private _scrollStrategy: VirtualScrollStrategy,\n              @Optional() dir: Directionality,\n              scrollDispatcher: ScrollDispatcher,\n              /**\n               * @deprecated `viewportRuler` parameter to become required.\n               * @breaking-change 11.0.0\n               */\n              @Optional() viewportRuler?: ViewportRuler) {\n    super(elementRef, scrollDispatcher, ngZone, dir);\n\n    if (!_scrollStrategy) {\n      throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n    }\n\n    // @breaking-change 11.0.0 Remove null check for `viewportRuler`.\n    if (viewportRuler) {\n      this._viewportChanges = viewportRuler.change().subscribe(() => {\n        this.checkViewportSize();\n      });\n    }\n  }\n\n  ngOnInit() {\n    super.ngOnInit();\n\n    // It's still too early to measure the viewport at this point. Deferring with a promise allows\n    // the Viewport to be rendered with the correct size before we measure. We run this outside the\n    // zone to avoid causing more change detection cycles. We handle the change detection loop\n    // ourselves instead.\n    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n      this._measureViewportSize();\n      this._scrollStrategy.attach(this);\n\n      this.elementScrolled()\n          .pipe(\n              // Start off with a fake scroll event so we properly detect our initial position.\n              startWith(null!),\n              // Collect multiple events into one until the next animation frame. This way if\n              // there are multiple scroll events in the same frame we only need to recheck\n              // our layout once.\n              auditTime(0, SCROLL_SCHEDULER))\n          .subscribe(() => this._scrollStrategy.onContentScrolled());\n\n      this._markChangeDetectionNeeded();\n    }));\n  }\n\n  ngOnDestroy() {\n    this.detach();\n    this._scrollStrategy.detach();\n\n    // Complete all subjects\n    this._renderedRangeSubject.complete();\n    this._detachedSubject.complete();\n    this._viewportChanges.unsubscribe();\n\n    super.ngOnDestroy();\n  }\n\n  /** Attaches a `CdkVirtualForOf` to this viewport. */\n  attach(forOf: CdkVirtualForOf<any>) {\n    if (this._forOf) {\n      throw Error('CdkVirtualScrollViewport is already attached.');\n    }\n\n    // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n    // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n    // change detection loop ourselves.\n    this.ngZone.runOutsideAngular(() => {\n      this._forOf = forOf;\n      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n        const newLength = data.length;\n        if (newLength !== this._dataLength) {\n          this._dataLength = newLength;\n          this._scrollStrategy.onDataLengthChanged();\n        }\n        this._doChangeDetection();\n      });\n    });\n  }\n\n  /** Detaches the current `CdkVirtualForOf`. */\n  detach() {\n    this._forOf = null;\n    this._detachedSubject.next();\n  }\n\n  /** Gets the length of the data bound to this viewport (in number of items). */\n  getDataLength(): number {\n    return this._dataLength;\n  }\n\n  /** Gets the size of the viewport (in pixels). */\n  getViewportSize(): number {\n    return this._viewportSize;\n  }\n\n  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n  // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n  // setting it to something else, but its error prone and should probably be split into\n  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n\n  /** Get the current rendered range of items. */\n  getRenderedRange(): ListRange {\n    return this._renderedRange;\n  }\n\n  /**\n   * Sets the total size of all content (in pixels), including content that is not currently\n   * rendered.\n   */\n  setTotalContentSize(size: number) {\n    if (this._totalContentSize !== size) {\n      this._totalContentSize = size;\n      this._calculateSpacerSize();\n      this._markChangeDetectionNeeded();\n    }\n  }\n\n  /** Sets the currently rendered range of indices. */\n  setRenderedRange(range: ListRange) {\n    if (!rangesEqual(this._renderedRange, range)) {\n      this._renderedRangeSubject.next(this._renderedRange = range);\n      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n    }\n  }\n\n  /**\n   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n   */\n  getOffsetToRenderedContentStart(): number | null {\n    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n  }\n\n  /**\n   * Sets the offset from the start of the viewport to either the start or end of the rendered data\n   * (in pixels).\n   */\n  setRenderedContentOffset(offset: number, to: 'to-start' | 'to-end' = 'to-start') {\n    // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n    // in the negative direction.\n    const isRtl = this.dir && this.dir.value == 'rtl';\n    const isHorizontal = this.orientation == 'horizontal';\n    const axis = isHorizontal ? 'X' : 'Y';\n    const axisDirection = isHorizontal && isRtl ? -1 : 1;\n    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n    this._renderedContentOffset = offset;\n    if (to === 'to-end') {\n      transform += ` translate${axis}(-100%)`;\n      // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n      // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n      // expand upward).\n      this._renderedContentOffsetNeedsRewrite = true;\n    }\n    if (this._renderedContentTransform != transform) {\n      // We know this value is safe because we parse `offset` with `Number()` before passing it\n      // into the string.\n      this._renderedContentTransform = transform;\n      this._markChangeDetectionNeeded(() => {\n        if (this._renderedContentOffsetNeedsRewrite) {\n          this._renderedContentOffset -= this.measureRenderedContentSize();\n          this._renderedContentOffsetNeedsRewrite = false;\n          this.setRenderedContentOffset(this._renderedContentOffset);\n        } else {\n          this._scrollStrategy.onRenderedOffsetChanged();\n        }\n      });\n    }\n  }\n\n  /**\n   * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n   * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n   * @param offset The offset to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n   */\n  scrollToOffset(offset: number, behavior: ScrollBehavior = 'auto') {\n    const options: ExtendedScrollToOptions = {behavior};\n    if (this.orientation === 'horizontal') {\n      options.start = offset;\n    } else {\n      options.top = offset;\n    }\n    this.scrollTo(options);\n  }\n\n  /**\n   * Scrolls to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n   */\n  scrollToIndex(index: number,  behavior: ScrollBehavior = 'auto') {\n    this._scrollStrategy.scrollToIndex(index, behavior);\n  }\n\n  /**\n   * Gets the current scroll offset from the start of the viewport (in pixels).\n   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n   *     in horizontal mode.\n   */\n  measureScrollOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number {\n    return from ?\n      super.measureScrollOffset(from) :\n      super.measureScrollOffset(this.orientation === 'horizontal' ? 'start' : 'top');\n  }\n\n  /** Measure the combined size of all of the rendered items. */\n  measureRenderedContentSize(): number {\n    const contentEl = this._contentWrapper.nativeElement;\n    return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n  }\n\n  /**\n   * Measure the total combined size of the given range. Throws if the range includes items that are\n   * not rendered.\n   */\n  measureRangeSize(range: ListRange): number {\n    if (!this._forOf) {\n      return 0;\n    }\n    return this._forOf.measureRangeSize(range, this.orientation);\n  }\n\n  /** Update the viewport dimensions and re-render. */\n  checkViewportSize() {\n    // TODO: Cleanup later when add logic for handling content resize\n    this._measureViewportSize();\n    this._scrollStrategy.onDataLengthChanged();\n  }\n\n  /** Measure the viewport size. */\n  private _measureViewportSize() {\n    const viewportEl = this.elementRef.nativeElement;\n    this._viewportSize = this.orientation === 'horizontal' ?\n        viewportEl.clientWidth : viewportEl.clientHeight;\n  }\n\n  /** Queue up change detection to run. */\n  private _markChangeDetectionNeeded(runAfter?: Function) {\n    if (runAfter) {\n      this._runAfterChangeDetection.push(runAfter);\n    }\n\n    // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n    // properties sequentially we only have to run `_doChangeDetection` once at the end.\n    if (!this._isChangeDetectionPending) {\n      this._isChangeDetectionPending = true;\n      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n        this._doChangeDetection();\n      }));\n    }\n  }\n\n  /** Run change detection. */\n  private _doChangeDetection() {\n    this._isChangeDetectionPending = false;\n\n    // Apply the content transform. The transform can't be set via an Angular binding because\n    // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n    // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n    // the `Number` function first to coerce it to a numeric value.\n    this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n    // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n    // from the root, since the repeated items are content projected in. Calling `detectChanges`\n    // instead does not properly check the projected content.\n    this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n\n    const runAfterChangeDetection = this._runAfterChangeDetection;\n    this._runAfterChangeDetection = [];\n    for (const fn of runAfterChangeDetection) {\n      fn();\n    }\n  }\n\n  /** Calculates the `style.width` and `style.height` for the spacer element. */\n  private _calculateSpacerSize() {\n    this._totalContentHeight =\n        this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n    this._totalContentWidth =\n        this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ArrayDataSource,\n  CollectionViewer,\n  DataSource,\n  ListRange,\n  isDataSource,\n} from '@angular/cdk/collections';\nimport {\n  Directive,\n  DoCheck,\n  EmbeddedViewRef,\n  Input,\n  IterableChangeRecord,\n  IterableChanges,\n  IterableDiffer,\n  IterableDiffers,\n  NgIterable,\n  NgZone,\n  OnDestroy,\n  SkipSelf,\n  TemplateRef,\n  TrackByFunction,\n  ViewContainerRef,\n} from '@angular/core';\nimport {Observable, Subject, of as observableOf, isObservable} from 'rxjs';\nimport {pairwise, shareReplay, startWith, switchMap, takeUntil} from 'rxjs/operators';\nimport {CdkVirtualScrollViewport} from './virtual-scroll-viewport';\n\n\n/** The context for an item rendered by `CdkVirtualForOf` */\nexport type CdkVirtualForOfContext<T> = {\n  /** The item value. */\n  $implicit: T;\n  /** The DataSource, Observable, or NgIterable that was passed to *cdkVirtualFor. */\n  cdkVirtualForOf: DataSource<T> | Observable<T[]> | NgIterable<T>;\n  /** The index of the item in the DataSource. */\n  index: number;\n  /** The number of items in the DataSource. */\n  count: number;\n  /** Whether this is the first item in the DataSource. */\n  first: boolean;\n  /** Whether this is the last item in the DataSource. */\n  last: boolean;\n  /** Whether the index is even. */\n  even: boolean;\n  /** Whether the index is odd. */\n  odd: boolean;\n};\n\n\n/** Helper to extract size from a DOM Node. */\nfunction getSize(orientation: 'horizontal' | 'vertical', node: Node): number {\n  const el = node as Element;\n  if (!el.getBoundingClientRect) {\n    return 0;\n  }\n  const rect = el.getBoundingClientRect();\n  return orientation == 'horizontal' ? rect.width : rect.height;\n}\n\n\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\n@Directive({\n  selector: '[cdkVirtualFor][cdkVirtualForOf]',\n})\nexport class CdkVirtualForOf<T> implements CollectionViewer, DoCheck, OnDestroy {\n  /** Emits when the rendered view of the data changes. */\n  viewChange = new Subject<ListRange>();\n\n  /** Subject that emits when a new DataSource instance is given. */\n  private _dataSourceChanges = new Subject<DataSource<T>>();\n\n  /** The DataSource to display. */\n  @Input()\n  get cdkVirtualForOf(): DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined {\n    return this._cdkVirtualForOf;\n  }\n  set cdkVirtualForOf(value: DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined) {\n    this._cdkVirtualForOf = value;\n    if (isDataSource(value)) {\n      this._dataSourceChanges.next(value);\n    } else {\n      // Slice the value if its an NgIterable to ensure we're working with an array.\n      this._dataSourceChanges.next(new ArrayDataSource<T>(\n          isObservable(value) ? value : Array.prototype.slice.call(value || [])));\n    }\n  }\n  _cdkVirtualForOf: DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined;\n\n  /**\n   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n   * the item and produces a value to be used as the item's identity when tracking changes.\n   */\n  @Input()\n  get cdkVirtualForTrackBy(): TrackByFunction<T> | undefined {\n    return this._cdkVirtualForTrackBy;\n  }\n  set cdkVirtualForTrackBy(fn: TrackByFunction<T> | undefined) {\n    this._needsUpdate = true;\n    this._cdkVirtualForTrackBy = fn ?\n        (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) :\n        undefined;\n  }\n  private _cdkVirtualForTrackBy: TrackByFunction<T> | undefined;\n\n  /** The template used to stamp out new elements. */\n  @Input()\n  set cdkVirtualForTemplate(value: TemplateRef<CdkVirtualForOfContext<T>>) {\n    if (value) {\n      this._needsUpdate = true;\n      this._template = value;\n    }\n  }\n\n  /**\n   * The size of the cache used to store templates that are not being used for re-use later.\n   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n   */\n  @Input() cdkVirtualForTemplateCacheSize: number = 20;\n\n  /** Emits whenever the data in the current DataSource changes. */\n  dataStream: Observable<T[] | ReadonlyArray<T>> = this._dataSourceChanges\n      .pipe(\n          // Start off with null `DataSource`.\n          startWith(null!),\n          // Bundle up the previous and current data sources so we can work with both.\n          pairwise(),\n          // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n          // new one, passing back a stream of data changes which we run through `switchMap` to give\n          // us a data stream that emits the latest data from whatever the current `DataSource` is.\n          switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),\n          // Replay the last emitted data when someone subscribes.\n          shareReplay(1));\n\n  /** The differ used to calculate changes to the data. */\n  private _differ: IterableDiffer<T> | null = null;\n\n  /** The most recent data emitted from the DataSource. */\n  private _data: T[] | ReadonlyArray<T>;\n\n  /** The currently rendered items. */\n  private _renderedItems: T[];\n\n  /** The currently rendered range of indices. */\n  private _renderedRange: ListRange;\n\n  /**\n   * The template cache used to hold on ot template instancess that have been stamped out, but don't\n   * currently need to be rendered. These instances will be reused in the future rather than\n   * stamping out brand new ones.\n   */\n  private _templateCache: EmbeddedViewRef<CdkVirtualForOfContext<T>>[] = [];\n\n  /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n  private _needsUpdate = false;\n\n  private _destroyed = new Subject<void>();\n\n  constructor(\n      /** The view container to add items to. */\n      private _viewContainerRef: ViewContainerRef,\n      /** The template to use when stamping out new items. */\n      private _template: TemplateRef<CdkVirtualForOfContext<T>>,\n      /** The set of available differs. */\n      private _differs: IterableDiffers,\n      /** The virtual scrolling viewport that these items are being rendered in. */\n      @SkipSelf() private _viewport: CdkVirtualScrollViewport,\n      ngZone: NgZone) {\n    this.dataStream.subscribe(data => {\n      this._data = data;\n      this._onRenderedDataChange();\n    });\n    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\n      this._renderedRange = range;\n      ngZone.run(() => this.viewChange.next(this._renderedRange));\n      this._onRenderedDataChange();\n    });\n    this._viewport.attach(this);\n  }\n\n  /**\n   * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n   * in the specified range. Throws an error if the range includes items that are not currently\n   * rendered.\n   */\n  measureRangeSize(range: ListRange, orientation: 'horizontal' | 'vertical'): number {\n    if (range.start >= range.end) {\n      return 0;\n    }\n    if (range.start < this._renderedRange.start || range.end > this._renderedRange.end) {\n      throw Error(`Error: attempted to measure an item that isn't rendered.`);\n    }\n\n    // The index into the list of rendered views for the first item in the range.\n    const renderedStartIndex = range.start - this._renderedRange.start;\n    // The length of the range we're measuring.\n    const rangeLen = range.end - range.start;\n\n    // Loop over all root nodes for all items in the range and sum up their size.\n    let totalSize = 0;\n    let i = rangeLen;\n    while (i--) {\n      const view = this._viewContainerRef.get(i + renderedStartIndex) as\n          EmbeddedViewRef<CdkVirtualForOfContext<T>> | null;\n      let j = view ? view.rootNodes.length : 0;\n      while (j--) {\n        totalSize += getSize(orientation, view!.rootNodes[j]);\n      }\n    }\n\n    return totalSize;\n  }\n\n  ngDoCheck() {\n    if (this._differ && this._needsUpdate) {\n      // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n      // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n      // changing (need to do this diff).\n      const changes = this._differ.diff(this._renderedItems);\n      if (!changes) {\n        this._updateContext();\n      } else {\n        this._applyChanges(changes);\n      }\n      this._needsUpdate = false;\n    }\n  }\n\n  ngOnDestroy() {\n    this._viewport.detach();\n\n    this._dataSourceChanges.next();\n    this._dataSourceChanges.complete();\n    this.viewChange.complete();\n\n    this._destroyed.next();\n    this._destroyed.complete();\n\n    for (let view of this._templateCache) {\n      view.destroy();\n    }\n  }\n\n  /** React to scroll state changes in the viewport. */\n  private _onRenderedDataChange() {\n    if (!this._renderedRange) {\n      return;\n    }\n    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n    if (!this._differ) {\n      this._differ = this._differs.find(this._renderedItems).create(this.cdkVirtualForTrackBy);\n    }\n    this._needsUpdate = true;\n  }\n\n  /** Swap out one `DataSource` for another. */\n  private _changeDataSource(oldDs: DataSource<T> | null, newDs: DataSource<T> | null):\n    Observable<T[] | ReadonlyArray<T>> {\n\n    if (oldDs) {\n      oldDs.disconnect(this);\n    }\n\n    this._needsUpdate = true;\n    return newDs ? newDs.connect(this) : observableOf();\n  }\n\n  /** Update the `CdkVirtualForOfContext` for all views. */\n  private _updateContext() {\n    const count = this._data.length;\n    let i = this._viewContainerRef.length;\n    while (i--) {\n      let view = this._viewContainerRef.get(i) as EmbeddedViewRef<CdkVirtualForOfContext<T>>;\n      view.context.index = this._renderedRange.start + i;\n      view.context.count = count;\n      this._updateComputedContextProperties(view.context);\n      view.detectChanges();\n    }\n  }\n\n  /** Apply changes to the DOM. */\n  private _applyChanges(changes: IterableChanges<T>) {\n    // Rearrange the views to put them in the right location.\n    changes.forEachOperation((record: IterableChangeRecord<T>,\n                              adjustedPreviousIndex: number | null,\n                              currentIndex: number | null) => {\n      if (record.previousIndex == null) {  // Item added.\n        const view = this._insertViewForNewItem(currentIndex!);\n        view.context.$implicit = record.item;\n      } else if (currentIndex == null) {  // Item removed.\n        this._cacheView(this._detachView(adjustedPreviousIndex !));\n      } else {  // Item moved.\n        const view = this._viewContainerRef.get(adjustedPreviousIndex!) as\n            EmbeddedViewRef<CdkVirtualForOfContext<T>>;\n        this._viewContainerRef.move(view, currentIndex);\n        view.context.$implicit = record.item;\n      }\n    });\n\n    // Update $implicit for any items that had an identity change.\n    changes.forEachIdentityChange((record: IterableChangeRecord<T>) => {\n      const view = this._viewContainerRef.get(record.currentIndex!) as\n          EmbeddedViewRef<CdkVirtualForOfContext<T>>;\n      view.context.$implicit = record.item;\n    });\n\n    // Update the context variables on all items.\n    const count = this._data.length;\n    let i = this._viewContainerRef.length;\n    while (i--) {\n      const view = this._viewContainerRef.get(i) as EmbeddedViewRef<CdkVirtualForOfContext<T>>;\n      view.context.index = this._renderedRange.start + i;\n      view.context.count = count;\n      this._updateComputedContextProperties(view.context);\n    }\n  }\n\n  /** Cache the given detached view. */\n  private _cacheView(view: EmbeddedViewRef<CdkVirtualForOfContext<T>>) {\n    if (this._templateCache.length < this.cdkVirtualForTemplateCacheSize) {\n      this._templateCache.push(view);\n    } else {\n      const index = this._viewContainerRef.indexOf(view);\n\n      // It's very unlikely that the index will ever be -1, but just in case,\n      // destroy the view on its own, otherwise destroy it through the\n      // container to ensure that all the references are removed.\n      if (index === -1) {\n        view.destroy();\n      } else {\n        this._viewContainerRef.remove(index);\n      }\n    }\n  }\n\n  /** Inserts a view for a new item, either from the cache or by creating a new one. */\n  private _insertViewForNewItem(index: number): EmbeddedViewRef<CdkVirtualForOfContext<T>> {\n    return this._insertViewFromCache(index) || this._createEmbeddedViewAt(index);\n  }\n\n  /** Update the computed properties on the `CdkVirtualForOfContext`. */\n  private _updateComputedContextProperties(context: CdkVirtualForOfContext<any>) {\n    context.first = context.index === 0;\n    context.last = context.index === context.count - 1;\n    context.even = context.index % 2 === 0;\n    context.odd = !context.even;\n  }\n\n  /** Creates a new embedded view and moves it to the given index */\n  private _createEmbeddedViewAt(index: number): EmbeddedViewRef<CdkVirtualForOfContext<T>> {\n    // Note that it's important that we insert the item directly at the proper index,\n    // rather than inserting it and the moving it in place, because if there's a directive\n    // on the same node that injects the `ViewContainerRef`, Angular will insert another\n    // comment node which can throw off the move when it's being repeated for all items.\n    return this._viewContainerRef.createEmbeddedView(this._template, {\n      $implicit: null!,\n      // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n      // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n      cdkVirtualForOf: this._cdkVirtualForOf!,\n      index: -1,\n      count: -1,\n      first: false,\n      last: false,\n      odd: false,\n      even: false\n    }, index);\n  }\n\n  /** Inserts a recycled view from the cache at the given index. */\n  private _insertViewFromCache(index: number): EmbeddedViewRef<CdkVirtualForOfContext<T>>|null {\n    const cachedView = this._templateCache.pop();\n    if (cachedView) {\n      this._viewContainerRef.insert(cachedView, index);\n    }\n    return cachedView || null;\n  }\n\n  /** Detaches the embedded view at the given index. */\n  private _detachView(index: number): EmbeddedViewRef<CdkVirtualForOfContext<T>> {\n    return this._viewContainerRef.detach(index) as\n        EmbeddedViewRef<CdkVirtualForOfContext<T>>;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {PlatformModule} from '@angular/cdk/platform';\nimport {NgModule} from '@angular/core';\nimport {CdkFixedSizeVirtualScroll} from './fixed-size-virtual-scroll';\nimport {CdkScrollable} from './scrollable';\nimport {CdkVirtualForOf} from './virtual-for-of';\nimport {CdkVirtualScrollViewport} from './virtual-scroll-viewport';\n\n@NgModule({\n  exports: [CdkScrollable],\n  declarations: [CdkScrollable]\n})\nexport class CdkScrollableModule {}\n\n@NgModule({\n  imports: [\n    BidiModule,\n    PlatformModule,\n    CdkScrollableModule\n  ],\n  exports: [\n    BidiModule,\n    CdkScrollableModule,\n    CdkFixedSizeVirtualScroll,\n    CdkVirtualForOf,\n    CdkVirtualScrollViewport,\n  ],\n  declarations: [\n    CdkFixedSizeVirtualScroll,\n    CdkVirtualForOf,\n    CdkVirtualScrollViewport,\n  ],\n})\nexport class ScrollingModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport * from './fixed-size-virtual-scroll';\nexport * from './scroll-dispatcher';\nexport * from './scrollable';\nexport * from './scrolling-module';\nexport * from './viewport-ruler';\nexport * from './virtual-for-of';\nexport * from './virtual-scroll-strategy';\nexport * from './virtual-scroll-viewport';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]},"metadata":{},"sourceType":"module"}