{"ast":null,"code":"import _classCallCheck from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/mnt/c/Users/francesco/Desktop/material-angular-dashboard/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport { Directive, Input, InjectionToken, ElementRef, Optional, Self, Inject, NgZone, HostListener, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport { NgControl, NgForm, FormGroupDirective } from '@angular/forms';\nimport { mixinErrorState, ErrorStateMatcher } from '@angular/material/core';\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `@angular/cdk/text-field` instead.\n * @breaking-change 8.0.0\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/forms';\nimport * as ɵngcc3 from '@angular/material/core';\nimport * as ɵngcc4 from '@angular/cdk/text-field';\n\nvar MatTextareaAutosize =\n/** @class */\nfunction () {\n  var MatTextareaAutosize = /*#__PURE__*/function (_CdkTextareaAutosize) {\n    _inherits(MatTextareaAutosize, _CdkTextareaAutosize);\n\n    var _super = _createSuper(MatTextareaAutosize);\n\n    function MatTextareaAutosize() {\n      _classCallCheck(this, MatTextareaAutosize);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(MatTextareaAutosize, [{\n      key: \"matAutosizeMinRows\",\n      get: function get() {\n        return this.minRows;\n      },\n      set: function set(value) {\n        this.minRows = value;\n      }\n    }, {\n      key: \"matAutosizeMaxRows\",\n      get: function get() {\n        return this.maxRows;\n      },\n      set: function set(value) {\n        this.maxRows = value;\n      }\n    }, {\n      key: \"matAutosize\",\n      get: function get() {\n        return this.enabled;\n      },\n      set: function set(value) {\n        this.enabled = value;\n      }\n    }, {\n      key: \"matTextareaAutosize\",\n      get: function get() {\n        return this.enabled;\n      },\n      set: function set(value) {\n        this.enabled = value;\n      }\n    }]);\n\n    return MatTextareaAutosize;\n  }(CdkTextareaAutosize);\n\n  MatTextareaAutosize.ɵfac = function MatTextareaAutosize_Factory(t) {\n    return ɵMatTextareaAutosize_BaseFactory(t || MatTextareaAutosize);\n  };\n\n  MatTextareaAutosize.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: MatTextareaAutosize,\n    selectors: [[\"textarea\", \"mat-autosize\", \"\"], [\"textarea\", \"matTextareaAutosize\", \"\"]],\n    hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\", \"mat-autosize\"],\n    inputs: {\n      cdkAutosizeMinRows: \"cdkAutosizeMinRows\",\n      cdkAutosizeMaxRows: \"cdkAutosizeMaxRows\",\n      matAutosizeMinRows: \"matAutosizeMinRows\",\n      matAutosizeMaxRows: \"matAutosizeMaxRows\",\n      matAutosize: [\"mat-autosize\", \"matAutosize\"],\n      matTextareaAutosize: \"matTextareaAutosize\"\n    },\n    exportAs: [\"matTextareaAutosize\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  MatTextareaAutosize.propDecorators = {\n    matAutosizeMinRows: [{\n      type: Input\n    }],\n    matAutosizeMaxRows: [{\n      type: Input\n    }],\n    matAutosize: [{\n      type: Input,\n      args: ['mat-autosize']\n    }],\n    matTextareaAutosize: [{\n      type: Input\n    }]\n  };\n  var ɵMatTextareaAutosize_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatTextareaAutosize);\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(MatTextareaAutosize, [{\n      type: Directive,\n      args: [{\n        selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n        exportAs: 'matTextareaAutosize',\n        inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n        host: {\n          'class': 'cdk-textarea-autosize mat-autosize',\n          // Textarea elements that have the directive applied should have a single row by default.\n          // Browsers normally show two rows by default and therefore this limits the minRows binding.\n          'rows': '1'\n        }\n      }]\n    }], null, {\n      matAutosizeMinRows: [{\n        type: Input\n      }],\n      matAutosizeMaxRows: [{\n        type: Input\n      }],\n      matAutosize: [{\n        type: Input,\n        args: ['mat-autosize']\n      }],\n      matTextareaAutosize: [{\n        type: Input\n      }]\n    });\n  })();\n\n  return MatTextareaAutosize;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\n\n\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(\"Input type \\\"\".concat(type, \"\\\" isn't supported by matInput.\"));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\n\n\nvar MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\n\nvar MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\nvar nextUniqueId = 0; // Boilerplate for applying mixins to MatInput.\n\n/** @docs-private */\n\nvar MatInputBase = function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup,\n/** @docs-private */\nngControl) {\n  _classCallCheck(this, MatInputBase);\n\n  this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n  this._parentForm = _parentForm;\n  this._parentFormGroup = _parentFormGroup;\n  this.ngControl = ngControl;\n};\n\nvar _MatInputMixinBase = mixinErrorState(MatInputBase);\n/** Directive that allows a native input to work inside a `MatFormField`. */\n\n\nvar MatInput =\n/** @class */\nfunction () {\n  var MatInput = /*#__PURE__*/function (_MatInputMixinBase2) {\n    _inherits(MatInput, _MatInputMixinBase2);\n\n    var _super2 = _createSuper(MatInput);\n\n    function MatInput(_elementRef, _platform,\n    /** @docs-private */\n    ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n      var _this;\n\n      _classCallCheck(this, MatInput);\n\n      _this = _super2.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n      _this._elementRef = _elementRef;\n      _this._platform = _platform;\n      _this.ngControl = ngControl;\n      _this._autofillMonitor = _autofillMonitor;\n      _this._uid = \"mat-input-\".concat(nextUniqueId++);\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n      _this.focused = false;\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n      _this.stateChanges = new Subject();\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n      _this.controlType = 'mat-input';\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n      _this.autofilled = false;\n      _this._disabled = false;\n      _this._required = false;\n      _this._type = 'text';\n      _this._readonly = false;\n      _this._neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(function (t) {\n        return getSupportedInputTypes().has(t);\n      });\n      var element = _this._elementRef.nativeElement;\n      var nodeName = element.nodeName.toLowerCase(); // If no input value accessor was explicitly specified, use the element as the input value\n      // accessor.\n\n      _this._inputValueAccessor = inputValueAccessor || element;\n      _this._previousNativeValue = _this.value; // Force setter to be called in case id was not specified.\n\n      _this.id = _this.id; // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n      // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n      // exists on iOS, we only bother to install the listener on iOS.\n\n      if (_platform.IOS) {\n        ngZone.runOutsideAngular(function () {\n          _elementRef.nativeElement.addEventListener('keyup', function (event) {\n            var el = event.target;\n\n            if (!el.value && !el.selectionStart && !el.selectionEnd) {\n              // Note: Just setting `0, 0` doesn't fix the issue. Setting\n              // `1, 1` fixes it for the first time that you type text and\n              // then hold delete. Toggling to `1, 1` and then back to\n              // `0, 0` seems to completely fix it.\n              el.setSelectionRange(1, 1);\n              el.setSelectionRange(0, 0);\n            }\n          });\n        });\n      }\n\n      _this._isServer = !_this._platform.isBrowser;\n      _this._isNativeSelect = nodeName === 'select';\n      _this._isTextarea = nodeName === 'textarea';\n\n      if (_this._isNativeSelect) {\n        _this.controlType = element.multiple ? 'mat-native-select-multiple' : 'mat-native-select';\n      }\n\n      return _this;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n\n    _createClass(MatInput, [{\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this2 = this;\n\n        if (this._platform.isBrowser) {\n          this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {\n            _this2.autofilled = event.isAutofilled;\n\n            _this2.stateChanges.next();\n          });\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        this.stateChanges.next();\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.stateChanges.complete();\n\n        if (this._platform.isBrowser) {\n          this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n        }\n      }\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        if (this.ngControl) {\n          // We need to re-evaluate this on every change detection cycle, because there are some\n          // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n          // that whatever logic is in here has to be super lean or we risk destroying the performance.\n          this.updateErrorState();\n        } // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n\n\n        this._dirtyCheckNativeValue();\n      }\n      /** Focuses the input. */\n\n    }, {\n      key: \"focus\",\n      value: function focus(options) {\n        this._elementRef.nativeElement.focus(options);\n      } // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n      // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n      // ViewEngine they're overwritten.\n      // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n\n      /** Callback for the cases where the focused state of the input changes. */\n      // tslint:disable:no-host-decorator-in-concrete\n      // tslint:enable:no-host-decorator-in-concrete\n\n    }, {\n      key: \"_focusChanged\",\n      value: function _focusChanged(isFocused) {\n        if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\n          this.focused = isFocused;\n          this.stateChanges.next();\n        }\n      } // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n      // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n      // ViewEngine they're overwritten.\n      // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n      // tslint:disable-next-line:no-host-decorator-in-concrete\n\n    }, {\n      key: \"_onInput\",\n      value: function _onInput() {// This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n      }\n      /** Does some manual dirty checking on the native input `value` property. */\n\n    }, {\n      key: \"_dirtyCheckNativeValue\",\n      value: function _dirtyCheckNativeValue() {\n        var newValue = this._elementRef.nativeElement.value;\n\n        if (this._previousNativeValue !== newValue) {\n          this._previousNativeValue = newValue;\n          this.stateChanges.next();\n        }\n      }\n      /** Make sure the input is a supported type. */\n\n    }, {\n      key: \"_validateType\",\n      value: function _validateType() {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n          throw getMatInputUnsupportedTypeError(this._type);\n        }\n      }\n      /** Checks whether the input type is one of the types that are never empty. */\n\n    }, {\n      key: \"_isNeverEmpty\",\n      value: function _isNeverEmpty() {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n      }\n      /** Checks whether the input is invalid based on the native validation. */\n\n    }, {\n      key: \"_isBadInput\",\n      value: function _isBadInput() {\n        // The `validity` property won't be present on platform-server.\n        var validity = this._elementRef.nativeElement.validity;\n        return validity && validity.badInput;\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"setDescribedByIds\",\n\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n      value: function setDescribedByIds(ids) {\n        this._ariaDescribedby = ids.join(' ');\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"onContainerClick\",\n      value: function onContainerClick() {\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n        if (!this.focused) {\n          this.focus();\n        }\n      }\n    }, {\n      key: \"disabled\",\n      get: function get() {\n        if (this.ngControl && this.ngControl.disabled !== null) {\n          return this.ngControl.disabled;\n        }\n\n        return this._disabled;\n      },\n      set: function set(value) {\n        this._disabled = coerceBooleanProperty(value); // Browsers may not fire the blur event if the input is disabled too quickly.\n        // Reset from here to ensure that the element doesn't become stuck.\n\n        if (this.focused) {\n          this.focused = false;\n          this.stateChanges.next();\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"id\",\n      get: function get() {\n        return this._id;\n      },\n      set: function set(value) {\n        this._id = value || this._uid;\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"required\",\n      get: function get() {\n        return this._required;\n      },\n      set: function set(value) {\n        this._required = coerceBooleanProperty(value);\n      }\n      /** Input type of the element. */\n\n    }, {\n      key: \"type\",\n      get: function get() {\n        return this._type;\n      },\n      set: function set(value) {\n        this._type = value || 'text';\n\n        this._validateType(); // When using Angular inputs, developers are no longer able to set the properties on the native\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\n        // with the native property. Textarea elements don't support the type property or attribute.\n\n\n        if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n          this._elementRef.nativeElement.type = this._type;\n        }\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"value\",\n      get: function get() {\n        return this._inputValueAccessor.value;\n      },\n      set: function set(value) {\n        if (value !== this.value) {\n          this._inputValueAccessor.value = value;\n          this.stateChanges.next();\n        }\n      }\n      /** Whether the element is readonly. */\n\n    }, {\n      key: \"readonly\",\n      get: function get() {\n        return this._readonly;\n      },\n      set: function set(value) {\n        this._readonly = coerceBooleanProperty(value);\n      }\n    }, {\n      key: \"empty\",\n      get: function get() {\n        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n      }\n      /**\n       * Implemented as part of MatFormFieldControl.\n       * @docs-private\n       */\n\n    }, {\n      key: \"shouldLabelFloat\",\n      get: function get() {\n        if (this._isNativeSelect) {\n          // For a single-selection `<select>`, the label should float when the selected option has\n          // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n          // overlapping the label with the options.\n          var selectElement = this._elementRef.nativeElement;\n          var firstOption = selectElement.options[0]; // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n          // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n\n          return this.focused || selectElement.multiple || !this.empty || !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n        } else {\n          return this.focused || !this.empty;\n        }\n      }\n    }]);\n\n    return MatInput;\n  }(_MatInputMixinBase);\n\n  MatInput.ɵfac = function MatInput_Factory(t) {\n    return new (t || MatInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ErrorStateMatcher), ɵngcc0.ɵɵdirectiveInject(MAT_INPUT_VALUE_ACCESSOR, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AutofillMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MatInput.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: MatInput,\n    selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n    hostAttrs: [1, \"mat-input-element\", \"mat-form-field-autofill-control\"],\n    hostVars: 10,\n    hostBindings: function MatInput_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focus\", function MatInput_focus_HostBindingHandler() {\n          return ctx._focusChanged(true);\n        })(\"blur\", function MatInput_blur_HostBindingHandler() {\n          return ctx._focusChanged(false);\n        })(\"input\", function MatInput_input_HostBindingHandler() {\n          return ctx._onInput();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled)(\"required\", ctx.required);\n        ɵngcc0.ɵɵattribute(\"id\", ctx.id)(\"placeholder\", ctx.placeholder)(\"readonly\", ctx.readonly && !ctx._isNativeSelect || null)(\"aria-describedby\", ctx._ariaDescribedby || null)(\"aria-invalid\", ctx.errorState)(\"aria-required\", ctx.required.toString());\n        ɵngcc0.ɵɵclassProp(\"mat-input-server\", ctx._isServer);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      disabled: \"disabled\",\n      required: \"required\",\n      type: \"type\",\n      value: \"value\",\n      readonly: \"readonly\",\n      placeholder: \"placeholder\",\n      errorStateMatcher: \"errorStateMatcher\"\n    },\n    exportAs: [\"matInput\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: MatFormFieldControl,\n      useExisting: MatInput\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  MatInput.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: Platform\n    }, {\n      type: NgControl,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Self\n      }]\n    }, {\n      type: NgForm,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: FormGroupDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ErrorStateMatcher\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Self\n      }, {\n        type: Inject,\n        args: [MAT_INPUT_VALUE_ACCESSOR]\n      }]\n    }, {\n      type: AutofillMonitor\n    }, {\n      type: NgZone\n    }];\n  };\n\n  MatInput.propDecorators = {\n    disabled: [{\n      type: Input\n    }],\n    id: [{\n      type: Input\n    }],\n    placeholder: [{\n      type: Input\n    }],\n    required: [{\n      type: Input\n    }],\n    type: [{\n      type: Input\n    }],\n    errorStateMatcher: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    readonly: [{\n      type: Input\n    }],\n    _focusChanged: [{\n      type: HostListener,\n      args: ['focus', ['true']]\n    }, {\n      type: HostListener,\n      args: ['blur', ['false']]\n    }],\n    _onInput: [{\n      type: HostListener,\n      args: ['input']\n    }]\n  };\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(MatInput, [{\n      type: Directive,\n      args: [{\n        selector: \"input[matInput], textarea[matInput], select[matNativeControl],\\n      input[matNativeControl], textarea[matNativeControl]\",\n        exportAs: 'matInput',\n        host: {\n          /**\n           * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n           */\n          'class': 'mat-input-element mat-form-field-autofill-control',\n          '[class.mat-input-server]': '_isServer',\n          // Native input properties that are overwritten by Angular inputs need to be synced with\n          // the native input element. Otherwise property bindings for those don't work.\n          '[attr.id]': 'id',\n          '[attr.placeholder]': 'placeholder',\n          '[disabled]': 'disabled',\n          '[required]': 'required',\n          '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n          '[attr.aria-describedby]': '_ariaDescribedby || null',\n          '[attr.aria-invalid]': 'errorState',\n          '[attr.aria-required]': 'required.toString()'\n        },\n        providers: [{\n          provide: MatFormFieldControl,\n          useExisting: MatInput\n        }]\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.ElementRef\n      }, {\n        type: ɵngcc1.Platform\n      }, {\n        type: ɵngcc2.NgControl,\n        decorators: [{\n          type: Optional\n        }, {\n          type: Self\n        }]\n      }, {\n        type: ɵngcc2.NgForm,\n        decorators: [{\n          type: Optional\n        }]\n      }, {\n        type: ɵngcc2.FormGroupDirective,\n        decorators: [{\n          type: Optional\n        }]\n      }, {\n        type: ɵngcc3.ErrorStateMatcher\n      }, {\n        type: undefined,\n        decorators: [{\n          type: Optional\n        }, {\n          type: Self\n        }, {\n          type: Inject,\n          args: [MAT_INPUT_VALUE_ACCESSOR]\n        }]\n      }, {\n        type: ɵngcc4.AutofillMonitor\n      }, {\n        type: ɵngcc0.NgZone\n      }];\n    }, {\n      id: [{\n        type: Input\n      }],\n      disabled: [{\n        type: Input\n      }],\n      required: [{\n        type: Input\n      }],\n      type: [{\n        type: Input\n      }],\n      value: [{\n        type: Input\n      }],\n      readonly: [{\n        type: Input\n      }],\n      _focusChanged: [{\n        type: HostListener,\n        args: ['focus', ['true']]\n      }, {\n        type: HostListener,\n        args: ['blur', ['false']]\n      }],\n      _onInput: [{\n        type: HostListener,\n        args: ['input']\n      }],\n      placeholder: [{\n        type: Input\n      }],\n      errorStateMatcher: [{\n        type: Input\n      }]\n    });\n  })();\n\n  return MatInput;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar MatInputModule =\n/** @class */\nfunction () {\n  var MatInputModule = function MatInputModule() {\n    _classCallCheck(this, MatInputModule);\n  };\n\n  MatInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: MatInputModule\n  });\n  MatInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function MatInputModule_Factory(t) {\n      return new (t || MatInputModule)();\n    },\n    providers: [ErrorStateMatcher],\n    imports: [[TextFieldModule, MatFormFieldModule], TextFieldModule, // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n    // be used together with `MatFormField`.\n    MatFormFieldModule]\n  });\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatInputModule, {\n      declarations: function declarations() {\n        return [MatInput, MatTextareaAutosize];\n      },\n      imports: function imports() {\n        return [TextFieldModule, MatFormFieldModule];\n      },\n      exports: function exports() {\n        return [TextFieldModule, // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n        // be used together with `MatFormField`.\n        MatFormFieldModule, MatInput, MatTextareaAutosize];\n      }\n    });\n  })();\n  /*@__PURE__*/\n\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(MatInputModule, [{\n      type: NgModule,\n      args: [{\n        declarations: [MatInput, MatTextareaAutosize],\n        imports: [TextFieldModule, MatFormFieldModule],\n        exports: [TextFieldModule, // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n        // be used together with `MatFormField`.\n        MatFormFieldModule, MatInput, MatTextareaAutosize],\n        providers: [ErrorStateMatcher]\n      }]\n    }], null, null);\n  })();\n\n  return MatInputModule;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, MatTextareaAutosize, getMatInputUnsupportedTypeError };","map":{"version":3,"sources":["../../../../../../src/material/input/autosize.ts","../../../../../../src/material/input/input-errors.ts","../../../../../../src/material/input/input-value-accessor.ts","../../../../../../src/material/input/input.ts","../../../../../../src/material/input/input-module.ts","../../../../../../src/material/input/public-api.ts","../../../../../../src/material/input/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CdkTextareaAutosize} from '@angular/cdk/text-field';\nimport {Directive, Input} from '@angular/core';\n\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `@angular/cdk/text-field` instead.\n * @breaking-change 8.0.0\n */\n@Directive({\n  selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n  exportAs: 'matTextareaAutosize',\n  inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n  host: {\n    'class': 'cdk-textarea-autosize mat-autosize',\n    // Textarea elements that have the directive applied should have a single row by default.\n    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n    'rows': '1',\n  },\n})\nexport class MatTextareaAutosize extends CdkTextareaAutosize {\n  @Input()\n  get matAutosizeMinRows(): number { return this.minRows; }\n  set matAutosizeMinRows(value: number) { this.minRows = value; }\n\n  @Input()\n  get matAutosizeMaxRows(): number { return this.maxRows; }\n  set matAutosizeMaxRows(value: number) { this.maxRows = value; }\n\n  @Input('mat-autosize')\n  get matAutosize(): boolean { return this.enabled; }\n  set matAutosize(value: boolean) { this.enabled = value; }\n\n  @Input()\n  get matTextareaAutosize(): boolean { return this.enabled; }\n  set matTextareaAutosize(value: boolean) { this.enabled = value; }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\nexport function getMatInputUnsupportedTypeError(type: string): Error {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport const MAT_INPUT_VALUE_ACCESSOR =\n    new InjectionToken<{value: any}>('MAT_INPUT_VALUE_ACCESSOR');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  Directive,\n  DoCheck,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Self,\n  HostListener,\n  AfterViewInit,\n} from '@angular/core';\nimport {FormGroupDirective, NgControl, NgForm} from '@angular/forms';\nimport {\n  CanUpdateErrorState,\n  CanUpdateErrorStateCtor,\n  ErrorStateMatcher,\n  mixinErrorState,\n} from '@angular/material/core';\nimport {MatFormFieldControl} from '@angular/material/form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit'\n];\n\nlet nextUniqueId = 0;\n\n// Boilerplate for applying mixins to MatInput.\n/** @docs-private */\nclass MatInputBase {\n  constructor(public _defaultErrorStateMatcher: ErrorStateMatcher,\n              public _parentForm: NgForm,\n              public _parentFormGroup: FormGroupDirective,\n              /** @docs-private */\n              public ngControl: NgControl) {}\n}\nconst _MatInputMixinBase: CanUpdateErrorStateCtor & typeof MatInputBase =\n    mixinErrorState(MatInputBase);\n\n/** Directive that allows a native input to work inside a `MatFormField`. */\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    /**\n     * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n     */\n    'class': 'mat-input-element mat-form-field-autofill-control',\n    '[class.mat-input-server]': '_isServer',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    '[attr.placeholder]': 'placeholder',\n    '[disabled]': 'disabled',\n    '[required]': 'required',\n    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n    '[attr.aria-describedby]': '_ariaDescribedby || null',\n    '[attr.aria-invalid]': 'errorState',\n    '[attr.aria-required]': 'required.toString()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput extends _MatInputMixinBase implements MatFormFieldControl<any>, OnChanges,\n    OnDestroy, AfterViewInit, DoCheck, CanUpdateErrorState {\n  protected _uid = `mat-input-${nextUniqueId++}`;\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  /** The aria-describedby attribute on the input for improved a11y. */\n  _ariaDescribedby: string;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    if (this.ngControl && this.ngControl.disabled !== null) {\n      return this.ngControl.disabled;\n    }\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string { return this._id; }\n  set id(value: string) { this._id = value || this._uid; }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean { return this._required; }\n  set required(value: boolean) { this._required = coerceBooleanProperty(value); }\n  protected _required = false;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string { return this._type; }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input() errorStateMatcher: ErrorStateMatcher;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string { return this._inputValueAccessor.value; }\n  set value(value: string) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean { return this._readonly; }\n  set readonly(value: boolean) { this._readonly = coerceBooleanProperty(value); }\n  private _readonly = false;\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week'\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(\n    protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>,\n    protected _platform: Platform,\n    /** @docs-private */\n    @Optional() @Self() public ngControl: NgControl,\n    @Optional() _parentForm: NgForm,\n    @Optional() _parentFormGroup: FormGroupDirective,\n    _defaultErrorStateMatcher: ErrorStateMatcher,\n    @Optional() @Self() @Inject(MAT_INPUT_VALUE_ACCESSOR) inputValueAccessor: any,\n    private _autofillMonitor: AutofillMonitor,\n    ngZone: NgZone) {\n\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n    this._inputValueAccessor = inputValueAccessor || element;\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(() => {\n        _elementRef.nativeElement.addEventListener('keyup', (event: Event) => {\n          let el = event.target as HTMLInputElement;\n          if (!el.value && !el.selectionStart && !el.selectionEnd) {\n            // Note: Just setting `0, 0` doesn't fix the issue. Setting\n            // `1, 1` fixes it for the first time that you type text and\n            // then hold delete. Toggling to `1, 1` and then back to\n            // `0, 0` seems to completely fix it.\n            el.setSelectionRange(1, 1);\n            el.setSelectionRange(0, 0);\n          }\n        });\n      });\n    }\n\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple ? 'mat-native-select-multiple' :\n                                                                   'mat-native-select';\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n  // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n  // ViewEngine they're overwritten.\n  // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n  /** Callback for the cases where the focused state of the input changes. */\n  // tslint:disable:no-host-decorator-in-concrete\n  @HostListener('focus', ['true'])\n  @HostListener('blur', ['false'])\n  // tslint:enable:no-host-decorator-in-concrete\n  _focusChanged(isFocused: boolean) {\n    if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n\n  // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n  // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n  // ViewEngine they're overwritten.\n  // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n  // tslint:disable-next-line:no-host-decorator-in-concrete\n  @HostListener('input')\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\n        !this.autofilled;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return this.focused || selectElement.multiple || !this.empty ||\n             !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n    } else {\n      return this.focused || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    this._ariaDescribedby = ids.join(' ');\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  static ngAcceptInputType_disabled: BooleanInput;\n  static ngAcceptInputType_readonly: BooleanInput;\n  static ngAcceptInputType_required: BooleanInput;\n\n  // Accept `any` to avoid conflicts with other directives on `<input>` that may\n  // accept different types.\n  static ngAcceptInputType_value: any;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {ErrorStateMatcher} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatTextareaAutosize} from './autosize';\nimport {MatInput} from './input';\n\n@NgModule({\n  declarations: [MatInput, MatTextareaAutosize],\n  imports: [\n    TextFieldModule,\n    MatFormFieldModule,\n  ],\n  exports: [\n    TextFieldModule,\n    // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n    // be used together with `MatFormField`.\n    MatFormFieldModule,\n    MatInput,\n    MatTextareaAutosize,\n  ],\n  providers: [ErrorStateMatcher],\n})\nexport class MatInputModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport * from './autosize';\nexport * from './input';\nexport * from './input-errors';\nexport * from './input-module';\nexport * from './input-value-accessor';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]},"metadata":{},"sourceType":"module"}